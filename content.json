{"pages":[{"title":"About 1인분 하고픈 DS","text":"늦은 나이에 데이터 분석이라는 직군을 알게되어 별 볼일 없는 모든 커리어를 접어둔채 데이터 탐색을 시작했습니다. 블로그를 통해 여러 사람들과 소통하고 싶고 여러 사람들에게 도움을 주고 싶습니다. 꾸준히 10년 이상 블로그 활동하려 합니다. 사람답게 1인분을 하고자 노력하고 있습니다. 혹시나 필요하실 수도 있어서 남깁니다. MacBook Pro (16-inch, 2019) 프로세서 : 2.3 GHz 8코어 Intel Core i9 메모리 : 16GB 2667 MHz DDR4 그래픽 : Intel UHD Graphics 630 1536 MB 블로그에 실린 모든 내용은 출처가 있는 내용을 저의 지극히 주관적인 관점으로 재해석해 올린 내용들입니다. 게시글 내용에 수정이 필요하거나 게시글이 불편하여 내리길 원하시면 아래 e-mail로 보내주시면 검토하여 진행하도록 하겠습니다. 감사합니다. About 페이지를 만드는데 도움주신 분께 감사드립니다. 출처 : https://kinetic27.github.io/2020/03/06/build-blog-with-hexo-github/#About-%ED%8E%98%EC%9D%B4%EC%A7%80","link":"/about/index.html"},{"title":"all-archives","text":"","link":"/all-archives/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"}],"posts":[{"title":"mysql","text":"Server - Database - Table 1. 데이터 베이스 보기SHOW DATABASES; 생성CREATE DATABASE test; 선택USE test 현재 확인SELECT DATABASE()","link":"/2020/05/08/AWS_server_mysql_query/"},{"title":"Agile","text":"Agile(애자일) 방법론 3줄 요약 작업 계획을 짧은 단위로 세우고 시제품을 만들어 나가는 사이클을 반복 고객의 요구 변화에 유연하고도 신속하게 대응하는 개발 방법론 자료출처 요즘 에자일, 에자일 기법에 대해 2번 이상 듣기도 하고 기업에서도 에자일 기법으로 프로세스를 진행한다고 하니 무엇인지에 대한 개념도 알아보고 내 삶에 적용 시키기도 해볼 겸해서 간단하게 기록하려합니다. 우선, 애자일 방법이란 ?기업경영 및 소프트웨어 등의 개발을 고객중심으로 진행하는 방법론 애자일방식의 조직운영 고객중심 아웃풋 중심 유연하고도 민첩한 대응력 자율성과 권한을 가진 조직 운영 에자일 개발 선언문 애자일 방법은 급변화하고 진화하고 있는 환경에 효과적으로 대응할 수 있는 방법이라고 생각됩니다. 피드백 댓글로 남겨주세요~!감사합니다 :)","link":"/2020/04/08/Agile/"},{"title":"tmux","text":"tmux(터미널 멀티플렉서) 실행, session name : dss 1$ tmux new -s dss 새로운 세션을 dss란 이름으로 만든다는 뜻 세션 종료 1$ exit 세션 목록보기 1$ tmux ls 세션 접속 1$ tmux attach -t dss 윈도우 생성 1$ ctrl + b, c 윈도우 이동 1$ ctrl + b, 0-9 윈도우 종료 1$ ctrl + b, &amp;","link":"/2020/05/08/AWS%20server_tmux/"},{"title":"Hexo 블로그 만들기","text":"안녕하세요!hexo 블로그 만드는 방법입니다. hexo 블로그 생성전 아래 2가지를 먼저 설치해야 합니다. Node.js Should be at least Node.js 8.10, recommends 10.0 or higher Git github에서 repository를 생성해야 합니다. 참고 사이트 hexo 블로그 공식 홈페이지 hexo 블로그 설치하기 공식문서 터미널을 엽니다. 블로그를 만들면 폴더가 생성됩니다. 폴더를 생성하고자 하는 곳으로 가셔서 아래의 $를 제외한 명령어를 입력하세요. 띄어쓰기 대소문자 모두 그대로 입력해주세요. 121. $ npm install hexo-cli -g2. $ hexo init blog 블로그를 만든 폴더로 이동합니다. 1235. $ cd blog6. $ npm install7. $ hexo server 로컬에서 hexo 블로그를 확인하실 수 있습니다. 아래 터미널의 경로로 가셔서 파일을 만듭니다. 터미널에서의 경로 본인이 만든 폴더 안의 source 폴더 안에 _post 1$ source/_posts/ ** 파일 이름(본인이 원하는 이름을 적으시면 됩니다.)** 파일명.md 파일 안에 원하는 내용을 적는데, 맨 위에 제목은 아래처럼 작성해주세요. 12345678---title: Hexo에 글을 쓰고 사이트에 반영하기---위처럼 제목을 적으셨으면 아래줄에 내용을 입력하면 됩니다. 1번 내용2번 내용 등주석을 적을 때는 `#`을 사용하여 적으시면 됩니다. 마크다운 문법 올릴 내용이 준비되었다면 아래와 같이 4가지 단계를 거쳐 블로그에 내용을 올리시면 됩니다. 1번: 헥소에 변화를 주겠다고 얘기한다.2번: 헥소에 내용을 반영하겠다고 얘기한다.3번: 헥소에 반영된 내용을 확인하겠다고 얘기한다. 수정이 필요하면 수정을 진행한다. 수정이 완료되면 아래 4번을 통해 내용을 공개하겠다고 얘기한다.4번: 블로그에 내용을 게시하겠다고 얘기한다. 터미널 창으로 가셔서 $ 표시 뒤의 글자를 치세요.1234$ hexo clean$ hexo generate$ hexo server # 생략가능, 로컬영역에서 확인$ hexo deploy 추가적인 내용은 지속적으로 편집하도록 하겠습니다. 최대한 자세히 쓰려고 노력중입니다.여러가지 의견 감사히 받겠습니다.댓글을 어떻게 활성화해야 하는지 몰라 여기저기 구글링중입니다. 댓글기능을 추가하였습니다.","link":"/2020/04/05/Hexo%20create/"},{"title":"Hexo profile 변경하기","text":"안녕하세요, Hexo Icarus theme의 프로필 사진을 변경하는 방법에 대해 알아보겠습니다. 아래와 같이 터미널에서 source 폴더 안에 img 폴더를 만든 후 img 폴더 안에 이미지 사진을 올리고 아래와 같이 작성하면 됩니다. 파일이름 대소문자를 구분한다고 하니 동일하게 진행하셔야 이미지가 보입니다. ![문자 사이에 공간이 없어야 합니다] 즉, 대쉬를 이용해서 문자와 문자 사이에 공간을 없애야 정상적으로 작동합니다. upload까지 약 3~4분 정도 소요되니 참고하시길 바랍니다. 1$ mkdir img Hexo 프로필 사진 변경 Hexo 프로필 아래 twitter 아이콘 제거하기 Hexo 블로그에 이미지 올리기 출처: 이카루스 테마 페이지","link":"/2020/04/25/Hexo-profile/"},{"title":"Hexo icarus 테마에 adsense 추가하기","text":"오늘은 Hexo icarus 테마에 adsense를 적용하는 것을 공유하려 합니다. 아래 구글 애드센스 홈페이지에 접속합니다. 구글애드센스 구글계정으로 로그인하고 애드센스를 신청합니다. Hexo icarus 테마 !_config.yml에 아래와 같이 등록합니다. 구글 에드센스 확인버튼을 누른 후 다음과 같은 이미지가 뜨면 승인을 기다립니다. 수고하셨습니다!","link":"/2020/05/04/Hexo-adsense/"},{"title":"visited_count","text":"블로그 방문자 수 설정하기 참조 사이트","link":"/2020/04/17/Hexo-visited-count/"},{"title":"cheatsheet","text":"나만의 cheatsheet 정리 math 김도형의 데이터 사이언스 스쿨 - 수학편 pandas pandas 날짜 데이터pandas cheatsheetpandas 10분 완성kaggle pandas cheatsheet seaborn seaborn cheatsheet 데이터 분석가 인터뷰 용어 정리 인터뷰 용어 정리 git 내용 정리 인프런 무료강좌 git과 githublearning_git","link":"/2020/04/29/cheatsheet/"},{"title":"git 기본 개념 및 계정 만들기","text":"git 1번째 내용 : 아래 인프런 무료강의를 시청한 후 작성하였습니다. 인프런 무료강좌 git과 github Git이란?형상 관리 시스템(version control system)의 한 종류입니다.주로 개발자들이 프로그램과 관련된 파일들을 저장하는데 사용합니다.게임의 세이브 포인트와 유사한데, 언제든지 저장 시점으로 되돌아 갈 수 있습니다. 절차 github 가입 github 저장소 생성 github 저장소 클론 내 컴퓨터의 내 문서 아래에 생성된 프로젝트 디렉토리에서 파일 생성 및 작업 완료 커밋할 파일들 선택해서 스테이지에 올리기(add) 커밋하기(commit) 푸시하기(push) github.com/내아이디/내프로젝트 링크를 통해서 정상적으로 업로드 되어있는지 확인 3가지 기본 개념 커밋(commit)게임의 세이브에 해당하는 행동입니다.언제든지 커밋한 시점으로 돌아갈 수 있습니다.저장을 원하는 파일들을 묶어서 커밋 명령을 수행하면 됩니다. 스테이지에 올린다(add)커밋전에 저장을 원하는 파일들을 묶는 일입니다.스테이지에 파일을 올리는 작업, 이를 간단히 줄여서 add라고 합니다. github에 업로드(push)커밋을 하면 현재 작업 내용의 세이브 데이터가 내 컴퓨터에 저장됩니다.github에 업로드하면 게임의 원격 저장과 비슷한 일을 합니다.다른 사람과 공유할 수 있고, 내 컴퓨터의 데이터가 날아가도 안전하게 다시 복구할 수 있습니다.github에 업로드 하는걸 git에서는 “push”라고 합니다. 직접 해 보기github.com 가입http://github.com/join을 통해 깃헙 가입을 합니다.주의사항 github은 아이디 노출도가 높습니다.개발자스러운 아이디를 신중하게 정합니다. 가입 후 이메일 인증을 해야 가입이 완료됩니다. 참고사항github의 캐릭터는 옥토캣입니다.개발자들 사이에서 인기가 매우 높다고 합니다.옥토캣 이미지 저장소 생성가입 후 저장소를 하나 만듭니다. Repository name 입력합니다. Description을 적습니다. Public으로 공개 설정합니다. initialize this repository with a README 박스를 체크합니다. Create repository, 초록색 new repository 버튼을 눌러서 저장소를 만듭니다. 저장소 주소를 메모장 등에 저장해 놓습니다. 저장소 주소의 규칙 : https://github.com/내아이디/저장소이름 입니다. 프로젝트와 repository 생성 참고 사이트","link":"/2020/04/15/git_ceate/"},{"title":"favicon","text":"favicon favicon 출처","link":"/2020/04/25/favicon/"},{"title":"git branch, git checkout, git merge","text":"git 3번째 내용 git branch 인프런 무료강좌 git과 github 병합하기 1 헤드 브랜치에 변경사항이 없고 병합 대상 브랜치가 헤드로부터 시작된 경우 아주 쉽게 병합 가능 = Fast-forward 병합하기 2 헤드 브랜치에 추가적인 커밋이 생기는 경우 진짜 변합이 필요합니다. 충돌이 나면 충돌난 부분을 확인한 후 해결하면 됩니다. soucetree에서 git branch branch : 기존 내용을 유지한 체 새로운 내용을 추가하고 싶을 때 사용합니다. checkout : 특정 브랜치(혹은 커밋)으로 돌아가고 싶을 때 사용합니다. sourcetree의 checkout : 브랜치 이름을 더블 클릭하여 체크아웃합니다. master : 고객에게 전달해야 하는 내용이 들어있습니다. branch : 개발을 진행하는 내용이 들어있습니다. merge : 하나의 브랜치를 현재 브랜치와 합치는 거을 병합(merge)라고 합니다. head branch : 현재 작업중인 브랜치 learn_git_branch git에서 bugFix라는 branch 만들기 터미널 명령어 : git branch 새로만들 브랜치 이름 1git branch bugFix git checkout bugFix 라는 명령어로 bugFix branch로 이동할 수 있습니다. 1git checkout bugFix 2-1. git checkout master 를 입력하면 master로 돌아갑니다. 1git checkout master Merge : 브랜치와 병합하기 각 브랜치에서 독립된 커밋이 하나씩 있을 경우, 이 경우는 지금까지 작업한 내용이 나뉘어 담겨있다는 뜻입니다. 이럴 때 두 브랜치를 합칠(merge) 수 있습니다. 1git merge bugFix git branch bugFix git commit git checkout master git commit 을 하면 아래와 같은 그림이 나옵니다. git merge bugFix git checkout bugFix git merge master 틀리거나 이상한 내용이 있으면 알려주세요, 확인 후 수정하겠습니다!","link":"/2020/05/05/git-branch/"},{"title":"markdown 문법에 대하여","text":"markdown 문법 사용법 출처 python is really cool python pandas depth1 depth2 numpy java c++ golang python java c++ 파이썬은 재밌다. y = 3x $y = 3x$ 12a = 10print(a) 12a = 10print(a) 파이썬 공식 페이지","link":"/2020/04/05/markdown-0/"},{"title":"안녕하세요 !!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/02/hello-world/"},{"title":"git clone과 sourceTree","text":"git 2번째 내용 : sourcetree 만들기 및 commit 주의사항 인프런 무료강좌 git과 github Source Tree 설치소스트리 다운로드주의사항 아틀라시안에 가입해야 합니다. bitbucket 등의 설정은 skip합니다. 소스트리를 설치한 후 저장소 클론github에 만들어진 README.md 등의 파일이 내 컴퓨터 문서폴더 안으로 복사됩니다.이 때, 내 컴퓨터 문서폴더 안에 저장소이름의 폴더가 생성됩니다. 작업 후 스테이지에 파일 추가만들어진 폴더를 열고 에디터 등을 이용해서 hello.html을 만들어 봅시다.저장위치는 Documents/hello-world/가 됩니다. 커밋 주의사항 반드시 한 번에 하나의 논리적인 작업만을 커밋합니다. 커밋 메세지를 잘 적어야 합니다.특히 커밋 메세지는 미래의 여러분과 다른 개발자를 위해서 꼼꼼히 적어야 합니다. 커밋 메세지 작성법 첫 줄에 간단하지만 명확하게 내용을 씁니다. 한줄 비웁니다. 자세한 내용을 적습니다. checkout을 이용해서 저장하지 않은 변경 내용 취소하기 checkout을 이용하면 마지막 커밋으로 되돌아갈 수 있습니다. sourceTree의 코드뭉치 버리기 기능을 사용하면 변경사항을 되돌릴 수 있습니다. commit 전 내용을 돌릴 수 있습니다.","link":"/2020/05/05/git_clone&sourceTree/"},{"title":"porject EDA","text":"EDA project 처음으로 진행했던 프로젝트 아파트 가격분석 EDA 자세한 내용은 아래 깃헙을 참고해주세요. EDA project Analysis APT price","link":"/2020/04/23/porject-EDA/"},{"title":"python class","text":"class 변수와 함수를 묶어 놓은 개념 사용방법 변수와 함수가 들어있는 클래스를 선언 클래스를 객체로 만들어서 클래스 안에 선언된 변수와 함수를 사용 첫번째 파라미터로 self를 사용 1. 클래스의 선언 기본 클래스의 사용 클래스 선언 -&gt; 객체로 만듬 -&gt; 객체에 함수를 호출12345678910class Calculator: # 총 4개의 변수 : num1, num2, plus, minus num1 = 1 num2 = 2 def plus(self): # 첫번째 파라미터로 self를 사용한다. return self.num1 + self.num2 # calc.num1 + calc.num2라는 의미 def minus(self): return self.num1 - self.num2 # calc.num1 - calc.num2라는 의미 123# 클래스의 사용calc = Calculator() # 객체 선언, 함수의 사용법과 같음calc 1calc.num1, calc.num2, calc.plus(), calc.minus() 12# self의 의미 : 객체 자신calc2 = Calculator() 12calc2.num1 = 10calc2.plus() 2. 객체지향 실제 세계를 코드에 반영해서 개발하는 방법 여러명의 개발자가 코드를 효율적으로 작성해서 프로젝트를 완성시키기 위한 방법 설계도 작성(class) -&gt; 실제 물건(object) 사용자 정의 데이터 타입 3. 생성자 클래스가 객체로 생성될 때 실행되는 함수 변수(재료)를 추가할 때 사용됩니다. 생성자 함수 클래스가 객체로 만들어질 때 객체에 선언되는 변수를 설정하는 방법 객체가 생성이 될 때 생성자 함수가 자동으로 실행되며, 에러 발생 시 객체로 만들 수 없습니다. 123456789101112class Calculator: # 생성자 함수 : __init_ def __init__(self, num1, num2=10): # default parameter 사용가능 self.num1 = num1 self.num2 = num2 def plus(self): return self.num1 + self.num2 def minus(self): return self.num1 - self.num2 1clac1 = Calculator(3, 4) 1clac1.plus() join() 리스트로 되어있는 데이터를 특정 문자열을 구분자로 사용해서 하나의 문장으로 만들어주는 함수12ls = ['python', 'is', 'good']\" \".join(ls) 12345678# pandas dataframeimport pandas as pddf = pd.DataFrame([ # DataFrame : class {\"name\": \"jin\", \"age\": 20}, {\"name\": \"andy\", \"age\": 21},])df id, pw 카운트 함수, 1. zip함수를 이용하는 방법 12345ls = ['a', 'b', 'c']print(list(range(len(ls))))print(list(zip(range(len(ls)), ls)))for idx, data in list(zip(range(len(ls)), ls)): print(idx, data) 1234user_datas = [ {'user': 'test', 'pw': '1234', 'count': 0}, {'user': 'python', 'pw': '5678', 'count': 0},] 123456789101112131415# user_data를 입력받아서 아이디와 패스워드를 체크하는 데코레이터 함수를 코드로 작성하세요. # 로그인 될 때마다 count를 1씩 증가def need_login(func): def wrapper(*args, **kwargs): # inner function 만듬 # 아아디 패스워드 입력 user, pw = tuple(input(\"insert user pw : \").split(' ')) # user와 pw 나눈 후 tuple로 변환 # 존재하는 아이디와 패스워드 확인 for idx, user_data in zip(range(len(user_datas)), user_datas): # 카운트하기 위해 몇 번째 데이터인지 확인필요 if (user_data['user'] == user) and (user_data['pw'] == pw): user_datas[idx]['count'] += 1 # 유저 데이터의 인덱스에서 카운트를 1씩 증가 시킴 # 함수 실행 return func(*args, **kwargs) # wrapper 함수 종료, 결과값 출력 return \"wrong login data!\" return wrapper 12345@need_logindef plus(num1, num2): return num1 + num2plus(1, 2) 1user_datas 2. enumerate함수를 이용하는 방법 1list(enumerate(user_datas)) 123456789101112131415# user_data를 입력받아서 아이디와 패스워드를 체크하는 데코레이터 함수를 코드로 작성하세요. # 로그인 될 때마다 count를 1씩 증가def need_login(func): def wrapper(*args, **kwargs): # inner function 만듬 # 아아디 패스워드 입력 user, pw = tuple(input(&quot;insert user pw : &quot;).split(' ')) # user와 pw 나눈 후 tuple로 변환 # 존재하는 아이디와 패스워드 확인 for idx, user_data in enumerate(user_datas): # 카운트하기 위해 몇 번째 데이터인지 확인필요 if (user_data['user'] == user) and (user_data['pw'] == pw): user_datas[idx]['count'] += 1 # 유저 데이터의 인덱스에서 카운트를 1씩 증가 시킴 # 함수 실행 return func(*args, **kwargs) # wrapper 함수 종료, 결과값 출력 return &quot;wrong login data!&quot; return wrapper 12345@need_logindef plus(num1, num2): return num1 + num2plus(1, 2) 1user_datas","link":"/2020/05/10/python_class/"},{"title":"basic","text":"파이썬 기본 문법 변수 선언, 식별자, 자료형, 형변환, 연산자 주석(comment)과 출력(print) 1234# 주석 : 앞에 #을 붙이면 코드로 실행이 안됩니다. # 코드에 대한 설명이나 코드를 실행시키고 싶지 않을 때 사용# 단축키 : ctrl(cmd) + /# 블럭설정 : shift + 방향키 123456# 출력 : print 함수# 코드 중간에 변수에 들어있는 값을 확인하고 싶을 때 사용# 1, 2, 3을 출력하는 코드, 아래를 실행시키면 1, 3이 출력 됩니다. print(1)# print(2)print(3) 12345# print 함수의 옵션# docstring : 함수에 대한 설명 : 단축키(shift + tab)print(1, 2, sep=\"-\", end=\"\\t\")print(3)# 자동완성 : tab 변수 선언 RAM 저장공간에 값을 할당하는 행위1234567# 하나씩 선언a = 1b = 2# 한줄로 여러개의 변수를 선언d, e = 3, 4# 5라는 값이 f와 g에 선언f = g = 5 식별자 변수, 함수, 클래스, 모듈 등의 이름을 식별자라고 합니다. 식별자 규칙 소문자, 대문자, 숫자, 언더스코어(_)를 사용합니다. 가장 앞에 숫자 사용 불가 예약어의 사용 불가 : def, class, try, except, 등 컨벤션- snake case : fast_campus : 변수, 함수 - camel case : FastCampus, fastCampus : 클래스 데이터 타입 RAM 저장공간을 효율적으로 사용하기 위해서 저장공간의 타입을 설정 동적타이핑(인터프리터 방식에서 주로 사용함)- 변수 선언시 저장되는 값에 따라서 자동으로 데이터 타입이 설정 기본 데이터 타입 : int, float, bool, str 컬렉션 데이터 타입 : list, tuple, dict 12345a = 1# int a = 1b = \"python\"# int, strtype(a), type(b) 123456# 기본 데이터 타입 : int, float, bool, stra = 1b = 1.2c = True # Falsed = \"data\"type(a), type(b), type(c), type(d) 1234# 데이터 타입의 함수 : 문자열d = \"data\"# upper : 대문자로 변환d.upper() 123f = ' THAt Car '# lower : 소문자로 변환f.lower() 12# strip : 공백 제거f.strip() 12# replace : 모든 공백제거f.replace(\" \", \"\") 12# replace : 특정 문자열 치환f.replace(\"THAt\", \"THIS\") 12# dir : 함수 확인dir(f) 123456789101112# 오프셋 인덱스 : 마스크, 마스킹 : []# 문자열은 순서가 있는 문자들의 집합g = \"abcdefg\"g[2] # 'c'g[-2] # 'f'g[2:5] # 'cde' 2는 포함, 5는 미포함g[2:] # 'cdefg' 2번째부터 끝까지g[:3] # 'abc' 0번째부터 2번째까지 g[0:3]과 같음g[-2:] # 'fg' -2에서 끝까지 g[:] # 'abcdefg' 처음부터 끝까지g[::2] # 'aceg' 2칸씩 점프하며 출력g[::-1] # 'gfedcba' 역순으로 출력 123456# 97531 출력numbers = '123456789' # numbers[::-2]# result = numbers[::2]# result[::-1]# numbers[::2][::-1] 1234# 컬렉션 데이터 타입 : list, tuple, dict# list [] : 순서가 있는 수정이 가능한 데이터 타입# tuple () : 순서가 있는 수정이 불가능한 데이터 타입# dict {} : 순서가 없고 키: 값으로 구성되어 있는 데이터 타입 123# listls = [1, 2, 3, \"four\", [5, 6], True, 1.2]type(ls), ls 12# offset index 사용 가능ls[3], ls[1:3], ls[::-1] 12345# list 함수ls = [1, 5, 2, 4]# append : 가장 뒤에 값을 추가ls.append(3)ls # [1, 5, 2, 4, 3] 12345# sort : 오름차순으로 정렬ls.sort()ls # [1, 2, 3, 4, 5]# 내림차순 정렬ls[::-1] # [5, 4, 3, 2, 1] 1234# pop : 가장 마지막 데이터를 출력하고 출력한 데이터를 삭제# ctrl + enter : 현재 셀을 계속 실행num = ls.pop()num, ls 1234# 리스트의 복사ls1 = [1, 2, 3]ls2 = ls1ls1, ls2 # ([1, 2, 3], [1, 2, 3]) 123# 얕은 복사 :주소값 복사ls1[2] = 5ls1, ls2 #([1, 2, 5], [1, 2, 5]) 깊은 복사 123# 깊은 복사ls3 = ls1.copy()ls1, ls3 #([1, 2, 5], [1, 2, 5]) 12ls1[2] = 10ls1, ls3 # ([1, 2, 10], [1, 2, 5]) tuple () 리스트와 같지만 수정이 불가능한 데이터 타입, 괄호 생략 가능 튜플은 리스트보다 같은 데이터를 가졌을 때 공간을 적게 사용123tp1 = 1, 2, 3tp2 = (4, 5, 6)type(tp1), type(tp2), tp1, tp2 12# offset index 사용 가능tp1[1], [tp1[::-1]] 12345678# 리스트와 튜플의 저장공간 차이 비교import sysls = [1, 2, 3]tp = (1, 2, 3)print(sys.getsizeof(ls), sys.getsizeof(tp))# 96 80 1234567891011**dict {}**- 순서가 없고 {키: 값}으로 구성되어 있는 데이터 타입```python# 선언: 키는 정수, 문자열 데이터 타입만 사용이 가능# 인덱스 대신 키를 사용dict = { 1: \"one\", \"two\": 2, 'tree': [1, 2, 3], }type(dic), dic 1234dic[1], dic[&quot;tree&quot;]```pythondic[&quot;two&quot;] = 123dic 123456789101112# 아래의 데이터를 list와 dict로 선언# 도시 : seoul, busan, daegu# 인구 : 9,700,000, 3,400,000, 2,400,000# 딕셔너리 : 변수 1개 선언data = { \"seoul\": 9700000, \"busan\": 3400000, \"daegu\": 2400000,}# 리스트 : 변수 2개 선언city = [seoul, busan, daegu]population = [9700000, 3400000, 2400000] 1sum(population) 1sum(data.values()) 형변환 데이터 타입을 변환하는 방법 int, float, bool, str, list, tuple, dict123a = 1b = \"2\"a + int(b) 1str(a) + b 1list(data.values()) 12345# zip : 같은 인덱스에 있는 데이터를 묶어주는 함수# zip 함수 사용하여 list 타입으로 변환하기list(zip(city, population))# dict 타입으로 변환하기dict(zip(city, population)) 12result = dict(list(zip(city, population)))result 1234567891011121314data1 = list(result.keys())data2 = list(resutl.values())data1, data2``` 6. 연산자 : 멤버 &gt; 논리 - 산술연산자 : +, -, *, /, //(몫), %(나머지), **(제곱)- 할당연산자 : 변수에 누적시켜서 연산 : +=, //=, **= 등- 비교연산자 : &gt;(크다), &lt;(작다), ==, !=, &lt;=(작거나 같다), &gt;=(크거나 같다), 결과로 True, False- 논리연산자 : True, False 를 연산 : or(T와 F연산 True가 출력), and(T와 T일 때 True), not(True를 False로 False를 True로 변경)- 멤버연산자 : 특정 데이터가 있는지 확인 할 때 사용 : not in, in```python# 산술연산 : 제곱, 나눗셈, 더하기 순1 + 4 / 2 ** 2 # 2.0 12345# 할당연산a = 10a +=10a += 10a # 30 12# 비교연산a &lt; b, a == b, a != b 123# 논리연산 : and(교집합), or(합집합), 괄호가 있는 경우에는 왼쪽이 먼저 연산됨True and False, True or False, not True or False # (not True = False가 되어 False or Flase는 False가 됨)# False, True, False 123ls = ['jin', 'andy', 'john']'andy' in ls, 'anchel' in ls, 'john' not in ls# True, False, False 1234# 랜덤함수import randomrandom.randint(1, 10) 123# 입력함수data = input('insert string : ')data 12345678910111213# 해결의 책 만들기 : 질문을 하면 질문에 대한 답변을 해주는 책# 1. solution을 리스트로 작성# 2. 질문 입력 받음# 3. 솔루션의 갯수에 맞게 랜덤한 index 정수 값을 생성# 4. index 해당하는 솔루션 리스트의 데이터를 출력solution =[ \"무엇을 하던 잘 풀릴 것이다.\", '생각지도 않게 좋은 일이 생길 것이다.', '무엇을 상상하던 그 이상이다.',]input(\"질문을 입력하세요. : \")idx = random.randint(0, len(solution) - 1) # 솔루션 = 총 3개: 0, 1, 2 이므로 솔루션 숫자 -1을 해야 randint(0, 2)가 됨solution[idx]","link":"/2020/05/09/python_basic_syntax/"},{"title":"python function","text":"함수 반복되는 코드를 묶음으로 효율적인 코드를 작성하도록 해주는 기능 기본 함수 파라미터와 아규먼트 리턴 args, *kwargs docstring scope inner function lambda function Map, Filter, Reduce Decorlator 1. 기본 함수 함수의 선언과 호출12345678# 함수선언def grade(point): # def : 예약어, 함수이름 : grade, 파라미터 : point if point &gt;= 90: print(\"A\") elif point &gt;= 80: print(\"B\") else: print(\"C\") 12# 함수호출grade(88) # 함수이름(point로 넘겨줄 값을 입력) 2. 파라미터와 아규먼트 파라미터: 함수를 선언할 때 호출하는 부분에서 보내주는 데이터를 받는 변수 아규먼트: 함수를 호출할 때 함수에 보내주는 데이터 123def plus(num1, num2): # 파라미터 print(num1 + num2)plus(1, 2) # 아규먼트 123def plus(num1, num2=10): # 디폴트 파라미터 print(num1 + num2)plus(1, 2) # 아규먼트 123def plus(num1, num2=10, num3=20): # 디폴트 파라미터 print(num1 + num2 - num3)plus(1, 2) # 아규먼트 키워드 아규먼트 : 특정 파라미터를 지정해서 넣고 싶을 때 사용1plus(3, num3=100) # 키워드 아규먼트 3. 리턴 함수를 실행한 결과를 저장하고 싶을 때 사용합니다. 함수에서 return 코드가 실행되면 무조건 함수가 종료됩니다. return12345def plus(num1, num2): print(num1 + num2)result = plus(1, 2)print(result) 123456def plus(num1, num2): print(num1 + num2) return num1 + num2result = plus(1, 2)print(result) 123456789def grade(point): # def : 예약어, 함수이름 : grade, 파라미터 : point if point &gt;= 90: return \"A\" elif point &gt;= 80: return \"B\" else: return \"C\"grade(90) 1234567def passornot(result): pass_ = \"\" if result == \"A\" or result == \"B\": return \"PASS\" else: return \"FAIL\"passornot(\"A\") 1234567891011121314def grade(point): # def : 예약어, 함수이름 : grade, 파라미터 : point if point &gt;= 90: return \"A\" elif point &gt;= 80: return \"B\" else: return \"C\"def passornot(result): pass_ = \"\" if result == \"A\" or result == \"B\": return \"PASS\" else: return \"FAIL\" 12# 함수 호출하기passornot(grade(98)) 12345# 함수에서 return 코드가 실행되면 무조건 함수가 종료됩니다. def echo(msg): if msg == 'quit': return print(msg) 4. args, *kwargs 함수를 호출할 때 아규먼트와 키워드 아규먼트의 갯수를 특정지을 수 없을 때 사용1234567# 갯수에 상관없이 모든 아규먼트를 더해주는 함수def plus(*args): print(type(args), args) return sum(args)# 함수 호출plus(1, 2, 3, 4, 5) 12345678# 키워드가 있는 아규먼트def plus(*args, **kwargs): print(type(args), args) print(type(kwargs), kwargs) return sum(args) + sum(kwargs.values())# 함수 실행plus(1, 2, 3, 4, 5, num1=6, num2=7) 12345def func(num1, num2, num3): return num1 + num2 + num3data = [1, 2, 3]func(*data) # func(1, 2, 3) 12345def func(num1, num2=10, num3=20): return sum(num1) + num2 + num3 data = [1, 2, 3]func(data) # func([1, 2, 3]) 12345def func(num1, num2, num3): return num1 + num2 + num3data = [1, 2, 3]func(*data) # func(1, 2, 3) 1234567def func(num1, num2, num3): return num1 + num2 + num3data = { \"num2\": 100, \"num3\": 200,}func(1, **data) # func(1, num2=100, num3=200) 문장을 입력받아서 문법에 맞도록 결과를 출력하는 코드를 작성마지막 문자는 . 이 있을수도 있고 없을수도 있습니다.논리적인 문제해결 순서 -&gt; 코드로 변경str.upper(), str.lower(), offset index [], str.add(문자열 덧셈)python IS the best Languagepython IS the best Language.Python is the best lagnuage. 1234567891011121314# 1. 문자열 입력받기sentence = input('input sentence : ')# 2. 모두 소문자로 변경result = sentence.lower() # lower함수는 리턴이 있는 함수이므로 result에 저장# 3. 가장 앞글자를 대문자로 변경result = result[0].upper() + result[1:] # 가장 앞글자 + 나머지 글자# 4. 마지막 문자가 .인지 확인해서 .이 아니면 .을 추가if result[-1] != \".\": result += \".\"result 12345678910111213141516171819# 6자리의 로또번호를 생성하는 코드를 작성하세요. # 6자리의 번호는 중복이 없어야 합니다. # 문자열, 숫자, 리스트# while, not in, in, list.append(), break, len(), list.sort()# 문제가 조금 복잡하면 간단한 기능부터 구현하고 업데이트를 하는 방법으로 해결# 랜덤한 숫자 6개 출력 -&gt; 숫자가 중복되지 않는 코드를 추가ilotto = []# 랜덤한 숫자 6개를 while문을 사용해서 작성while True: num = random.randint(1, 45) # 숫자를 추가할 때 lotto 리스트에 중복되는 숫자가 없으면 추가 if num not in lotto: lotto.append(num) if len(lotto) &gt;= 6: lotto.sort() break lotto 5. docstring 1234# 한줄로 작성def echo(msg): \"echo print msg\" print(msg) 1234567891011def echo(msg): \"\"\" echo func return its input agument The operation is: 1. print msg parameter 2. return msg parameter param : mag : str return : str \"\"\" print(msg) return msg 12# docstring 확인 방법echo? 1echo?? 1help(echo) 1print(echo.__doc__) 6. Scope 범위 함수 안에서 선언되는 변수와 함수 밖에서 선언되는 변수의 범위가 다릅니다. global(전역), local(지역) 전역영역에 선언되어있으면 함수가 실행될 때 전역영역의 변수를 가져다 사용합니다. 지역영역에 선언되어있으면 함수가 실행될 때 지역영역의 변수를 가져다 사용합니다. 메모리를 덜 잡아먹기 때문에 로컬영역에서 선언할 수 있으면 로컬에서 선언하는 것이 좋습니다. 1234567# globalgv = 10 def echo(): print(gv)echo() 123456789# localgv = 10 def echo(): gv = 100 print(gv)echo() # 100gv # 10 123456789gv = 10 def echo(): global gv gv=100 print(gv)echo()gv # 100 7. inner function 함수가 지역영역에 선언, 함수 안에 함수가 선언123456def outer(a, b): def inner(c, d): return c + d return inner(a, b) 1outer(1, 2) # 3 1inner(2, 3) # 오류발생 : 전역영역에서 지역영역의 함수를 사용하려 했기 때문입니다. 지역영역에 선언된 함수이므로 지역영역에서만 사용할 수 있습니다. inner함수 = 익명함수라고 부릅니다. 전역영역에서 가져다 사용할 수 없는 함수이기 때문입니다. 12345678910# 지역영역의 함수 사용하기def outer(a, b): def inner(c, d): print(a, b) return c + d return inner # 리턴을 변경시켜주고outer(1, 2)(3, 4) # inner(3, 4) 8. callback function 함수를 아규먼트, 파라미터로 설정해서 사용하는 것을 의미합니다. 1234567891011def calc(func, a, b): # code a **= 2 b **= 2 return func(a, b)def plus(a, b): return a + bdef minus(a, b): return a - b 12# 덧셈calc(plus, 1, 2) 12# 뺄셈calc(minus, 1, 2) 9. lambda function 파라미터를 간단한 계산으로 리턴되는 함수 : 삼항연산12345def plus(a, b): # 파라미터 return a + b # 리턴# lambda 파라미터: 리턴plus2 = lambda a, b: a + b 1plus2(2, 3) 1calc(lambda a, b: a + b, 4, 5) 10. Map, Filter, Reduce map: 순서가 있는 데이터 집합에서 모든 값에 함수를 적용시킨 결과를 출력 아규먼트로 func(함수), *iterable을 받음 iterable 한 데이터에 함수를 각 요소마다 모두 적용시킨 결과 데이터를 만들고 싶을 때 사용합니다. map(func, ls1, ls2) : ls(iterable한 데이터)가 여러개 올 수 있습니다. 123456ls = [1, 2, 3, 4]def odd_even(num): return 'odd' if num % 2 else 'even'odd_even(3), odd_even(4) 1list(map(odd_even, ls)) # 함수, 리스트를 넣음 12345678910# input 함수로 구분자는 \" \"으로 여러개의 숫자를 입력 받습니다. # str.split(\" \")리스트로 만들고# 만들어진 리스트의 값들을 int로 형변환datas = input(\"insert numbers : \") # 10 20 30 40 50 40 30 20 10result = datas.split(\" \")result``` ```pythonresult = list(map(int, result))result 10-2. Filter Filter : 리스트 데이터에서 특정 조건에 맞는 value만 남기는 함수 filter(func, ls) : ls(iterable한 데이터)가 1개밖에 못옵니다. True, False로 만듭니다. func is True인 것만 리턴합니다. 1234ls = range(10)# 홀수만 출력list(filter(lambda data: True if data % 2 else False, ls)) 10-3. Reduce 리스트 데이터를 처음부터 순서대로 특정 함수를 실행하여 결과를 누적시켜 주는 함수123456from functools import reduce # import 해야 사용 가능합니다. ls = [3, 1, 2, 4, 5]# ((((1+2)+3)+4)+5)# 파라미터가 반드시 2개여야 함reduce(lambda x, y: x + y, ls) 10. Decorlator 함수에서 코드를 바꾸지 않고 기능을 추가하거나 수정하고 싶을 때 사용하는 문법123456789def a(): code_1 code_2 code_3def b(): code_1 code_4 code_3 데코레이터의 사용 1234567891011121314151617def c(func): # 2. func으로 def a()이 들어옴 def wrapper(*args, **kwargs): # inner func code_1 # 4. 코드가 실행됨 result = func(*args, **kwargs) # 5. 코드가 실행됨 code_3 # 6. 코드가 실행됨 return result # 7. 반환함 return wrapper # 8. 반환함@c # 1. def c라는 함수가 실행이 됨, code_1, code_3 기능이 적용됨, code_1, 3, 2가 실행됨def a(): # def a라는 함수가 wrapper 함수로 변경됨 code_2 # 3. code_2 가 실행됨@c # code_1, code_3 기능이 실행됨, 결과적으로 code_1, 3, 4가 실행됨def b(): # b라는 함수가 wrapper 함수로 변경됨 code_4 12345678910111213141516171819202122# adef plus(a, b): print(\"start\") # code_1 result = a + b # code_2 print(\"result : {}\".format(result)) # code_3 return result# bdef minus(a, b): print(\"start\") # code_1 result = a - b # code_4 print(\"result : {}\".format(result)) # code_3 return result# c : code_1, cod_3을 묶어주는 데코레이션 함수def disp(func): def wrapper(*args, **kwargs): print(\"start\") # code_1 result = func(*args, **kwargs) # code_2, code_4 print(\"result : {}\".format(result)) # code_3 return result return wrapper 12345@dispdef plus(a, b): result = a + b # code_2 return resultplus(1, 2) 123456789101112# 함수의 실행 시간을 출력하는 데코레이터 함수를 작성하세요. import timedef timer(func): def wrapper(*args, **kwargs): start_time = time.time() # code 1 result = func(*args, **kwargs) # code 2, code 4 end_time = time.time() # code 3 print(\"running time : {}\".format(end_time - start_time)) # code 3 return result return wrapper 1234@timerdef test1(num1, num2): data = range(num1, num2+1) return sum(data) 123456@timerdef test2(num1, num2): result = 0 for num in range(num1, num2+1): result += num return result 1test1(1, 100000) 1test2(1, 100000) 12345678910111213141516# 패스워드를 입력받아야 함수가 실행되도록하는 데코레이터 작성def check_password(func): def wrapper(*args, **kwargs): pw = 'dss12'# datas = [# {'id': 'test', 'pw': '1234'},# {'id': 'test2', 'pw': '12345'}# ] # check password input_pw = input('insert pw : ') if input_pw == pw: result = func(*args, **kwargs) else: result = 'not allow!' return result return wrapper 123@check_passworddef plus(a, b): return a + b 1plus(1, 2) 1234567891011@check_passworddef lotto_func(): lotto = [] while True: number = random.randint(1, 45) if number not in lotto: lotto.append(number) if len(lotto) &gt;= 6: lotto.sort() break return lotto 1lotto_func()","link":"/2020/05/10/python_function/"},{"title":"jupyter notebook","text":"python coding program numpy, pandas, sklearn 등의 모듈을 각각 설치해야 함 anaconda numpy, pandas, sklearn 등의 모듈이 모두 포함되어 있음 용량이 큼(약 500MB) jupyter notebook mode 명령모드(esc) : 셀을 수정할 때 사용, 왼쪽 바의 색깔이 파란색입니다. 편집모드(enter) : 셀안의 내용을 수정할 때 사용, 왼쪽 바의 색깔이 녹색입니다. style markdown(명령모드 + m) : 셀 안에 설명을 작성할 때 사용 code(명령모드 + y) : 파이썬 코드를 작성할 때 사용 라인 넘버(명령모드 + l) 단축키 셀 실행 : shift + enter, ctrl + enter 셀 삭제 : (명령모드) x 되돌리기 : (명령모드) z 셀 생성 : (명령모드) a(위에), b(아래) 매직 커맨드 셀 내부에서 특별하게 동작하는 커맨드 % : 한줄의 magic command를 동작 %% : 셀 단위의 magic command를 동작 주요 magic command %pwd : 현재 주피터 노트북 파일의 경로 %ls : 현재 디렉토리의 파일 리스트 %whos : 현재 선언된 변수를 출력 %reset : 현재 선언된 변수를 모두 삭제 shell command 주피터 노트북을 실행 셀 환경의 명령을 사용 명령어 앞에 !를 붙여서 실행 주요 명령어 : ls, cat, echo 등 !echo python : 뒤에 오는 문자열(python)을 출력해줍니다. !ls : 현재 디렉토리에 있는 데이터를 표시해줍니다.","link":"/2020/05/09/python_jupyter_notebook/"},{"title":"project-LinearRegression","text":"Linear Regression project 한달동안 팀원들과 함께 한 프로젝트 홍성현님, 유호원님, 배준영님 한달동안 수고 많았습니다 :) 깃헙에서도 확인할 수 있습니다. Linear Regression project UsedCar price 선형회귀분석에 사용한 코드 정리 패키지 모듈 12345678910111213141516171819import reimport timeimport pandas as pdimport seaborn as snsimport missingno as msnoimport matplotlib as mplimport matplotlib.pylab as pltimport statsmodels.api as smfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import r2_scorefrom scipy import statsfrom sklearn import linear_modelfrom sklearn.metrics import mean_squared_errorfrom sklearn.model_selection import cross_val_scorefrom sklearn.model_selection import KFold# 컬럼 display 제한 상향pd.set_option('display.max_columns', -1)# 지수 표기법 해제pd.options.display.float_format = '{:.7f}'.format 로우데이터 임포트 1raw_data = pd.read_csv(\"./csv_file/vehicles.csv\") # ./ : 현재경로 결측치 확인 및 제거 123import missingno as msnomsno.matrix(start_df)plt.show() 결측치 수치화 123456def columns_na_percentage(df,columns): for column in columns: percentage = round(100 -(len(df['{}'.format(column)].dropna()) / len(df)) * 100,2) if percentage : print(\"{} : \".format(column), percentage, \"%\", end='\\n')columns_na_percentage(start_df, start_df.columns) 결측치 제거 12start_df = start_df.dropna(axis=0)print(\"결측치 제거후 Data : \", start_df.shape) price 컬럼 내용 확인 1raw_data['price'].describe() 1raw_data['price'].sort_values(ascending=False)[:10] 중복 데이터 제거 12start_df = start_df.loc[start_df['vin'].drop_duplicates(keep='last').index]print(\"중복 vin 삭제 Data : \", start_df.shape) VIN(차대번호) 크롤링 후 데이터 합치기 12345678910111213141516171819202122vin_crawling_data = pd.read_csv('./csv_file/final_vin_crawling.csv')# secend_half_crawling_data = pd.read_csv('./vin_crawling_addtional.csv')# vin_crawling_data = pd.concat([first_half_crawling_data, secend_half_crawling_data], axis=0)# 대문자 변경vin_crawling_data['vin'] = vin_crawling_data['vin'].str.upper()# 중복제거vin_crawling_data = vin_crawling_data.drop_duplicates('vin', keep='first')# 대문자 변경start_df['vin'] = start_df['vin'].str.upper()# mergemerged_df = pd.merge(start_df, vin_crawling_data, on='vin')# 중복 제거merged_df = merged_df.drop_duplicates('vin', keep='first')# 필요 없는 컬럼 제거df = merged_df[merged_df.columns.difference(['id_y', 'id_x', 'Unnamed: 0', 'Unnamed: 0.1', 'og_vin'])]print(\"크롤링 Data와 중복 vin 제거 data가 합쳐진 Data : \", df.shape) 에러 컬럼 삭제 1df['error'].value_counts() 1234df=df[df.columns.difference(['error'])]df = df.dropna(axis=0)msno.matrix(df)plt.show() 데이터 필터링 1234567def get_sigma_data_by_price(num): # price가 0인것들 제거 sigma = df[(df['price'] &gt;= (df['average'] - (df['stdev']*num))) &amp; (df['price'] &lt;= (df['average'] + (df['stdev']*num)))] return sigmasigma_2_df = get_sigma_data_by_price(2)print(\"2 sigma Data:\", sigma_2_df.shape) year 항목 int로 형변환 1sigma_2_df['year'] = sigma_2_df['year'].astype('int') 주행거리 아웃라이어 탐색 12print(\"주행거리가 잘못 입력된 차량 대수 : \",len(sigma_2_df[sigma_2_df['mileage'] != sigma_2_df['odometer']]))sigma_2_df[sigma_2_df['mileage'] != sigma_2_df['odometer']].sort_values(ascending=False,by='odometer').head(2) 12# 주행거리 아웃라이어 제거sigma_2_df = sigma_2_df[sigma_2_df['mileage'] == sigma_2_df['odometer']] 시각화: 박스플롯, 스캐터 플롯 12345678910plt.figure(figsize=(16,15))plt.subplot(311)sns.boxplot(x=\"year\", y=\"price\", data = sigma_2_df)plt.xticks(rotation=90)plt.title('연도별 가격 분포')plt.subplot(312)sns.scatterplot(sigma_2_df['year'],sigma_2_df['odometer'])plt.title(\"연도별 주행거리 분포\")plt.tight_layout()plt.show() 눈으로 확인 후 수정이 필요한 데이터 12# year 수정해 줘야 하는 데이터sigma_2_df[sigma_2_df['year'] &lt; 1980] 1sigma_2_df['year'] = sigma_2_df['year'].apply(lambda x : 2019 if x &lt; 1980 else x) 주행거리가 높은 차량 확인 1sigma_2_df[sigma_2_df['odometer'] &gt; 500000] 12# 일 평균 주행거리 계산하여 확인print(\"평균 주행거리 : \", round(533000.00 / (365 * 18), 2), \"마일/day\") 높은 가격의 차량 확인 1sigma_2_df[sigma_2_df['price'] &gt; 75000].sort_values(by=['price'],ascending=False).head() 12# 낮은 금액의 차량 확인sigma_2_df[sigma_2_df['price'] &lt; 500].sort_values(by=['price'],ascending=False) 12# 이상치 가격을 보이는 차량 제거sigma_2_df = sigma_2_df[(sigma_2_df['vin'] != '1GCWGFBA7C1155304') &amp; (sigma_2_df['vin'] != '1GCWGFBA8C1126880') &amp; (sigma_2_df['vin'] != '1FMCU03115KA47874')] 주행거리 0인 데이터 확인 및 제거 123print(\"판매자가 주행거리를 0으로 올려둔 경우 : \",len(sigma_2_df[sigma_2_df['odometer'] == 0]),\"건\")sigma_2_df[sigma_2_df['odometer'] == 0].head(2)sigma_2_df= sigma_2_df[sigma_2_df['odometer'] != 0] 분석에 필요한 컬럼 1234df = sigma_2_df[['price','year','odometer','drive','fuel','manufacturer','state','title_status','transmission','type','paint_color','cylinders']]df = df.reset_index(drop=True)msno.matrix(df)plt.show() 종속변수 : price 1df.price.sort_values(ascending=False)[:20] 123456789plt.figure(figsize=(17,6))plt.subplot(131)sns.distplot(np.log(df['price']))plt.subplot(132)sns.boxplot(np.log(df['price']))plt.subplot(133)stats.probplot(np.log(df['price']), plot=plt)plt.tight_layout()plt.show() 독립변수 확인 12345plt.figure(figsize=(16,8))sns.countplot(df['year'])plt.title(&quot;차량 제조연도&quot;)plt.xticks(rotation=90)plt.show() 주행거리 컬럼 확인 12345678plt.figure(figsize=(16,7))plt.subplot(121)sns.distplot(df['odometer'])plt.subplot(122)sns.distplot(df['odometer'])plt.tight_layout()plt.xlim(0,250000)plt.show() 카테고리 독립변수 확인 12345678910111213141516171819202122232425262728293031323334353637383940414243plt.figure(figsize=(15,20))plt.subplot(621)sns.countplot( data = df, y = \"fuel\", palette='Set1',)plt.title(\"연료 종류 - fuel\")plt.subplot(622)sns.countplot( data = df, y = \"cylinders\", palette='Set1', order = df['cylinders'].value_counts().index)plt.title(\"실린더 갯수 - cylinders\")plt.subplot(623)sns.countplot( data = df, y = \"transmission\", palette='Set1')plt.title(\"변속기 - transmission\")plt.subplot(624)sns.countplot( data = df, y = \"drive\", palette='Set1')plt.title(\"구동 방식 - drive\")plt.subplot(625)sns.countplot( data = df, y = \"title_status\", palette='Set1')plt.title(\"차량 상태 - title_status\")plt.tight_layout()plt.show() 12345678910111213141516171819202122232425262728293031323334353637plt.figure(figsize=(18,10))plt.subplot(221)sns.countplot( data = df, y = \"type\", palette='Set1', order = df['type'].value_counts().index)plt.title(\"차량 종류 - type\")plt.subplot(222)sns.countplot( data = df, y = \"paint_color\", palette='Set1', order = df['paint_color'].value_counts().index)plt.title(\"차량 색깔 - paint_color\")plt.subplot(223)sns.countplot( data = df, y = \"manufacturer\", palette='Set1', order = df['manufacturer'].value_counts().iloc[:7].index,)plt.title(\"제조사 - manufacturer\")plt.subplot(224)sns.countplot( data = df, y = \"state\", palette='Set1', order = df['state'].value_counts().iloc[:7].index)plt.title(\"주 - state\")plt.tight_layout()plt.show() 실수형 변수 상관분석 12sns.pairplot(df[['price','odometer','year']],size=3)plt.show() Partial Regression Plot(부분회귀분석) 12345678910111213141516fig = plt.figure(figsize=(20,8))ax1 = fig.add_subplot(1,2,1)ax2 = fig.add_subplot(1,2,2)others = list(set(df.columns).difference(set([\"price\", \"odometer\"])))p, resids = sm.graphics.plot_partregress( \"price\", \"odometer\", others, data=df, obs_labels=False, ret_coords=True, ax = ax1)others2 = list(set(df.columns).difference(set([\"price\", \"year\"])))p, resids = sm.graphics.plot_partregress( \"price\", \"year\", others2, data=df, obs_labels=False, ret_coords=True, ax = ax2)plt.tight_layout()plt.show() 모델링, 데이터 분할 12345678# 빈도수에 따른 필터링def value_counts_filter(num, columns): for column in columns: result = df[column].value_counts()[df[column].value_counts().sort_values() &lt; num] if len(result) !=0: print(result.values.sum()) print(result, end=\"\\n\\n===========\\n\\n\")value_counts_filter(10, df.columns.difference(['price', 'odometer', 'year'])) 2개 초과 10개 미만 데이터 인덱스 확인 123456789101112def check_under_10_index(start_num, end_num, columns, df): test = {} test2 = [] for column in columns: len_under_10 = len(df[column].value_counts()[(df[column].value_counts() &lt; end_num) &amp; (df[column].value_counts() &gt; start_num)]) if len_under_10: for i in range(len_under_10): index = df[df[column] == df[column].value_counts()[(df[column].value_counts() &lt; end_num) &amp; (df[column].value_counts() &gt; start_num)].index[i]].index.values value = df[column].value_counts()[(df[column].value_counts() &lt; end_num) &amp; (df[column].value_counts() &gt; start_num)].index[i] test[value] = index test2.append(test) return test2 12index_df = pd.DataFrame(check_under_10_index(2,10, ['cylinders', 'manufacturer', 'title_status', 'type'], df))index_df 데이터 분할에 사용할 인덱스 분류 123456789101112131415161718192021for_test_data = []for_train_data_train = []for_train_data_test = []for column in index_df.columns: start = list(index_df[column][0]) random.shuffle(start) if len(start) &gt; 4: m = [start[i:i + 3] for i in range(0, len(start), 3)] for_test_data.append(m[0]) for_train_data_train.append(m[1]) for_train_data_test.append(m[2]) elif len(start) == 4: m = [start[:2], start[2:3], start[3:]] for_test_data.append(m[0]) for_train_data_train.append(m[1]) for_train_data_test.append(m[2]) else : m = [[i] for i in start] for_test_data.append(m[0]) for_train_data_train.append(m[1]) for_train_data_test.append(m[2]) 10개 미만 데이터 우선 삭제 1234567def delete_under_ten(df): for column in df.columns.difference(['id', 'price', 'odometer', 'year']): values = [value for value in df[column].value_counts()[df[column].value_counts() &lt; 10].keys()] if values: for value in values: df = df[df[column] != value] return df 1df_deleted_under_ten = delete_under_ten(df) 2개 초과 10개 미만 데이터 균등 분배 1234567train_data, test_data = train_test_split(df_deleted_under_ten, test_size = .20, random_state = 7)train_data = pd.concat([train_data, df.iloc[ [element for array in for_train_data_train for element in array] + [element for array in for_train_data_test for element in array]]], axis=0)test_data = pd.concat([test_data,df.iloc[ [element for array in for_test_data for element in array]]])train_data.shape, test_data.shape 데이터 확인 12msno.matrix(train_data)plt.show() 선형회귀분석(LinearRegression) 1234567891011121314151617181920212223242526X = train_data[train_data.columns.difference(['id_x', 'model', 'vin', 'price'])]Y = np.log(train_data['price'])X = pd.get_dummies(data=X, drop_first=True)X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = .20, random_state = 0)test_df = pd.concat([Y_train, X_train], axis=1)model = linear_model.LinearRegression() result = model.fit(X_train, Y_train)predicted = result.predict(X_test)r2 = r2_score(Y_test,predicted)print('Test R2 score : ', r2)plt.scatter(Y_test,predicted)pred_tr = result.predict(X_train)pred_test = result.predict(X_test)rmse_tr = (np.sqrt(mean_squared_error(Y_train, pred_tr)))rmse_test = (np.sqrt((Y_test, pred_test)))# cv = KFold(10, shuffle=True, random_state=0)model_0_cross_val_score = cross_val_score(model, X, Y, scoring=None, cv=10)print('RMSE of Train Data : ', rmse_tr)print('RMSE of Test Data : ', rmse_test)print('K-fold : ', model_0_cross_val_score) Model 1 123from used_car_regression import UsedCarRegressionusedcar = UsedCarRegression(df)df.shape 12# 모델1 full rankmodel1_formula = \"np.log(price) ~ scale(odometer) + scale(year) +C(manufacturer)+C(cylinders)+C(drive)+C(fuel)+C(state)+C(title_status)+C(transmission)+C(type)+C(paint_color) + 0\" 123456789101112def summary_minimize_df(result, model_num): df = pd.DataFrame([{ \"R-squared\": result.rsquared, \"Adj. R-squared\": result.rsquared_adj, \"F-statistic\": result.fvalue, \"Prob (F-statistic)\": result.f_pvalue, \"Log-Likelihood\": result.llf, \"AIC\": result.aic, \"BIC\": result.bic }]).T df.columns = [model_num] return df 모델 학습 12result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model1_formula)pred = result.predict(test_data) 12model1_min_df = summary_minimize_df(result, \"Model 1\")model1_min_df 12# R2 score 확인r2_score(np.log(test_data['price']), pred) 교차 검증(cross validation) 12cross_validation_model1 = usedcar.cross_validation(model1_formula)cross_validation_model1 ANOVA 독립변수 확인 12anova = sm.stats.anova_lm(result, typ=2)anova.sort_values(by=['F'], ascending=False) Model 2 : 실수형 * 범주형 interaction 1234567891011121314151617181920212223242526272829Numbers = ['scale(odometer)', 'scale(year)']X = ['fuel', 'title_status', 'transmission', 'drive', 'type', 'paint_color',\"cylinders\", \"manufacturer\"]combination_score = []combination_name = []for number in Numbers: feature = number for i in X: interaction = feature + \":\" + i kf = KFold(5, shuffle=True, random_state=0) mode2_cross_val_score = [] for X_train_index, X_test_index in kf.split(train_data): X_train= train_data.iloc[X_train_index] X_test = train_data.iloc[X_test_index] X_train = pd.concat([X_train, train_data[train_data.index.isin([element for array in for_train_data_train for element in array])]], axis=0) X_test = pd.concat([X_test, train_data[train_data.index.isin([element for array in for_train_data_test for element in array])]], axis=0) model1 = sm.OLS.from_formula(\"np.log(price) ~ scale(odometer) + scale(year) +{}+{}\".format(\"+\".join(X_train.columns.difference([\"price\",'odometer','year'])), interaction), X_train) result = model1.fit() pred = result.predict(X_test) R2 = r2_score(np.log(X_test.price), pred) n = train_data.shape[0] p = len(pd.get_dummies(train_data).columns) Adjr2 = 1-(1-R2)*(n-1)/(n-p-1) mode2_cross_val_score.append(Adjr2) combination_score.append(mode2_cross_val_score) combination_name.append(interaction) 1234fig1, ax1 = plt.subplots(figsize=(14, 6))ax1.boxplot(combination_score)ax1.set_xticklabels(combination_name, rotation=90)plt.show() Model 2 formula 12model2_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color)\\+ scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel)\" 모델학습 1234result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model2_formula)pred = result.predict(test_data)model2_min_df = summary_minimize_df(result, 'Model 2')pd.concat([model1_min_df,model2_min_df], axis=1) 12# R2 scorer2_score(np.log(test_data['price']), pred) CV 12cross_validation_model2 = usedcar.cross_validation(model2_formula)cross_validation_model2 Model 3 : 범주형 * 범주형 interaction 1234567891011121314151617181920212223242526272829X = ['fuel', 'title_status', 'transmission', 'drive', 'type', 'paint_color', 'cylinders', 'manufacturer']combination_score = []combination_name = []for count in range(len(X)): feature = X[-1] X.pop() for i in X: interaction = feature + \":\" + i kf = KFold(5, shuffle=True, random_state=0) model_cross_val_score = [] for X_train_index, X_test_index in kf.split(train_data): X_train= train_data.iloc[X_train_index] X_test = train_data.iloc[X_test_index] X_train = pd.concat([X_train, train_data[train_data.index.isin([element for array in for_train_data_train for element in array])]], axis=0) X_test = pd.concat([X_test, train_data[train_data.index.isin([element for array in for_train_data_test for element in array])]], axis=0) model1 = sm.OLS.from_formula(\"np.log(price) ~ scale(odometer) + scale(year) + {} + {}\".format(\"+\".join(X_train.columns.difference(['price', 'odometer', 'year', feature, i])), interaction), X_train) result = model1.fit() pred = result.predict(X_test) R2 = r2_score(np.log(X_test.price),pred) n = train_data.shape[0] p = len(pd.get_dummies(train_data).columns) Adjr2 = 1-(1-R2)*(n-1)/(n-p-1) model_cross_val_score.append(Adjr2) combination_score.append(model_cross_val_score) combination_name.append(interaction) 1234fig1, ax1 = plt.subplots(figsize=(14, 6))ax1.boxplot(combination_score)ax1.set_xticklabels(combination_name, rotation=90)plt.show() 1model3_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive)\" 모델학습 1234result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model3_formula)pred = result.predict(test_data)model3_min_df = summary_minimize_df(result, 'Model 3')pd.concat([model1_min_df, model2_min_df, model3_min_df], axis=1) 12# R2 scorer2_score(np.log(test_data['price']), pred) CV 12cross_validation_model3 = usedcar.cross_validation(model3_formula)cross_validation_model3 Model 4 : year와 odometer 다항식 추가 12345678910111213141516# Partial Regression Plot을 확인하면 약간 2차방정식 모형처럼 보여서 진행fig = plt.figure(figsize=(20,8))ax1 = fig.add_subplot(1,2,1)ax2 = fig.add_subplot(1,2,2)others = list(set(df.columns).difference(set([\"price\", \"odometer\"])))p, resids = sm.graphics.plot_partregress( \"price\", \"odometer\", others, data=df, obs_labels=False, ret_coords=True, ax = ax1)others2 = list(set(df.columns).difference(set([\"price\", \"year\"])))p, resids = sm.graphics.plot_partregress( \"price\", \"year\", others2, data=df, obs_labels=False, ret_coords=True, ax = ax2)plt.tight_layout()plt.show() year에 제곱항을 더했을 때 12345678910score = []formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive)\"for i in range(1, 5): if i == 1: score.append(usedcar.cross_validation(formula)) else: formula += \" + scale(I(year**{}))\".format(i) score.append(usedcar.cross_validation(formula)) 12345name = ['1차항', '2차항', '3차항', '4차항']fig1, ax1 = plt.subplots(figsize=(14, 6))ax1.boxplot(score[:4])ax1.set_xticklabels(name)plt.show() odometer에 제곱항을 더했을 때 12345678910score = []formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color)\"for i in range(1,5): if i == 1: score.append(usedcar.cross_validation(formula)) else: formula += \" + scale(I(odometer**{}))\".format(i) score.append(usedcar.cross_validation(formula)) 12345name = ['1차항', '2차항', '3차항', '4차항']fig1, ax1 = plt.subplots(figsize=(14, 6))ax1.boxplot(score)ax1.set_xticklabels(name)plt.show() year와 odometer 3차항까지 추가한 모델 비교 123model4_1_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) + scale(I(odometer**2)) + scale(I(odometer**3)) \"model4_2_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) \" model4_3_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(odometer**2)) + scale(I(odometer**3)) \" 검증결과 비교 1234567891011121314cross_validation_model4_1 = usedcar.cross_validation(model4_1_formula)cross_validation_model4_2 = usedcar.cross_validation(model4_2_formula)cross_validation_model4_3 = usedcar.cross_validation(model4_3_formula)fig, ax = plt.subplots(figsize=(15, 8))ax.boxplot( [ cross_validation_model4_1, cross_validation_model4_2, cross_validation_model4_3 ], sym=\"b*\", labels=['Model 4_1(year, odometer 다차항)', 'Model 4_2(year 다차항)', 'Model 4_3(odometer 다차항)'],)plt.title('모델별 K-fold 검증 비교')plt.show() Model 4 결론 : year에 3차항까지 추가 1model4_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) \" 모델학습 1234result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model4_formula)pred = result.predict(test_data)model4_min_df = summary_minimize_df(result, 'Model 4')pd.concat([model1_min_df, model2_min_df, model3_min_df, model4_min_df], axis=1) 12# R2 score 확인r2_score(np.log(test_data['price']),pred) CV 12cross_validation_model4 = usedcar.cross_validation(model4_formula)cross_validation_model4 모델별 성능 비교 123456789101112fig, ax = plt.subplots(figsize=(15, 8))ax.boxplot( [ cross_validation_model1, cross_validation_model2, cross_validation_model3, cross_validation_model4, ], sym=\"b*\", labels=['Model 1', 'Model 2', 'Model 3', 'Model 4'],)plt.title('모델별 K-fold 검증 비교')plt.show() Model 5 : 중고차 워런티 제도로 odometer 분포 탐색 12345678plt.figure(figsize=(16,7))plt.subplot(121)sns.distplot(df['odometer'])plt.subplot(122)sns.distplot(df['odometer'])plt.tight_layout()plt.xlim(0,150000)plt.show() 6만 마일 기준, 이하 = 0, 초과 = 1 12df['odometer_under_100000'] = df['odometer'].apply(lambda x: 0 if x &gt;= 60000 else 1)df['odometer_under_100000'].unique() 1usedcar = UsedCarRegression(df) 1model5_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) + C(odometer_under_100000)\" 모델학습 1234result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model5_formula)pred = result.predict(test_data)model5_min_df = summary_minimize_df(result, 'Model 5')pd.concat([model1_min_df,model2_min_df,model3_min_df,model4_min_df,model5_min_df], axis=1) 12# R2 score 확인r2_score(np.log(test_data['price']), pred) 123# CVcross_validation_model5 = usedcar.cross_validation(model5_formula)cross_validation_model5 1234567891011121314# 모델별 성능비교fig, ax = plt.subplots(figsize=(15, 8))ax.boxplot( [ cross_validation_model1, cross_validation_model2, cross_validation_model3, cross_validation_model4, cross_validation_model5 ], sym=\"b*\", labels=['Model 1', 'Model 2', 'Model 3', 'Model 4', 'Model 5'],)plt.title('모델별 K-fold 검증 비교')plt.show() Model 6 : 성능이 가장 좋은 모델4에 Ridge, Lasso, Elastic Net 적용 주의 : 시간이 오래걸림, 기억으론 약 4시간 30분 정도 소요됨 12df = df.drop('odometer_under_100000',axis=1)df.shape 12345678910111213141516171819usedcar = UsedCarRegression(df)model6_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) \"result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model6_formula)# Lassofrom tqdm.notebook import tqdmbar_total = tqdm(np.arange(0.00001, 0.0005, 0.00001))lasso_ls=[]for i in bar_total: lasso_result = usedcar.regularized_method(model6_formula, cv=5, alpha=i ,L1_wt=1) lasso_ls.append({ \"alpha\" : i, \"Lasso\" : lasso_result })# 데이터 프레임으로 저장lasso_df = pd.DataFrame(lasso_ls)lasso_df.to_csv('./lasso.csv') 12345678910111213# Ridgefrom tqdm.notebook import tqdmbar_total = tqdm(np.arange(0.00001, 0.0005, 0.00001))ridge_ls=[]for i in bar_total: ridge_result = usedcar.regularized_method(model6_formula, cv=5, alpha=i, L1_wt=0) ridge_ls.append({ \"alpha\" : i, \"Ridge\" : ridge_result })ridge_df = pd.DataFrame(ridge_ls)ridge_df.to_csv('./ridge.csv') 1234567891011# Elastic_netfrom tqdm.notebook import tqdmbar_total = tqdm(np.arange(0.00001, 0.0005, 0.00001))elastic_net_ls=[]for i in bar_total: elastic_net_result = usedcar.regularized_method(model6_formula, cv=5, alpha=i, L1_wt=0.5) elastic_net_ls.append({ \"alpha\" : i, \"Elastic_net\" : elastic_net_result }) 123elastic_net_df = pd.read_csv('./csv_file/elastic.csv', index_col=[0])ridge_df = pd.read_csv('./csv_file/ridge.csv', index_col=[0])lasso_df = pd.read_csv('./csv_file/lasso.csv', index_col=[0]) 123lasso_df['Lasso'] = lasso_df['Lasso'].str.extract(r'(0[.][0-9]*)').astype('float')ridge_df['Ridge'] = ridge_df['Ridge'].str.extract(r'(0[.][0-9]*)').astype('float')elastic_net_df['Elastic_net'] = elastic_net_df['Elastic_net'].str.extract(r'(0[.][0-9]*)').astype('float') 123456plt.figure(figsize=(16,8))plt.plot('alpha','Lasso', data=lasso_df)plt.plot('alpha','Ridge', data=ridge_df)plt.plot('alpha','Elastic_net', data=elastic_net_df)plt.legend()plt.show() 1model6_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3))\" 1usedcar = UsedCarRegression(df) 1result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model6_formula) 12score, result, cross_validation_model6 = usedcar.regularized_method( model6_formula, cv=10, alpha=0.00001, L1_wt=0) K-Fold 검증 성능 비교12345678910111213# odometer 6만fig, ax = plt.subplots(figsize=(15, 8))ax.boxplot( [ cross_validation_model1, cross_validation_model2, cross_validation_model3, cross_validation_model4, cross_validation_model5, cross_validation_model6 ], sym=\"b*\", labels=['Model 1', 'Model 2', 'Model 3', 'Model 4', 'Model 5', 'Model 6'],)plt.title('모델별 K-fold 검증 비교')plt.show() 모델별 Test 데이터로 예측한 R-quare1model1_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color)\" 1234result = usedcar.model_fit(model1_formula)prediction = result[0].predict(test_data[test_data.columns.difference(['price'])])model_1_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 1 R-sqaure : \", model_1_test_r2) 1model2_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer)\" 1234result= usedcar.model_fit(model2_formula)prediction = result[0].predict(test_data[test_data.columns.difference(['price'])])model_2_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 2 R-sqaure : \", model_2_test_r2) 1model3_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + C(manufacturer):C(cylinders) + C(type):C(drive)\" 1234result= usedcar.model_fit(model3_formula)prediction = result[0].predict(test_data[test_data.columns.difference(['price'])])model_3_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 3 R-sqaure : \", model_3_test_r2) 1model4_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) \" 12345result = usedcar.model_fit(model4_formula)prediction = result[0].predict(test_data[test_data.columns.difference( ['price'])])model_4_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 4 R-sqaure : \", model_4_test_r2) 1model5_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type)+scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3)) + C(odometer_under_100000)\" 1df['odometer_under_100000'] = df['odometer'].apply(lambda x: 0 if x &gt;= 60000 else 1) 1usedcar = UsedCarRegression(df) 1test_data['odometer_under_100000'] = test_data['odometer'].apply(lambda x: 0 if x &gt;= 60000 else 1) 12345result = usedcar.model_fit(model5_formula)prediction = result[0].predict(test_data[test_data.columns.difference( ['price'])])model_5_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 5 R-sqaure : \", model_5_test_r2) 12test_data = test_data.drop('odometer_under_100000', axis=1)df = df.drop('odometer_under_100000', axis=1) 1model6_formula = \"np.log(price) ~ scale(odometer) + scale(year) + C(manufacturer) + C(cylinders) + C(drive) + C(fuel) + C(state) + C(title_status) + C(transmission) + C(type) + C(paint_color) + scale(odometer):C(cylinders) + scale(odometer):C(type) + scale(year):C(manufacturer) + scale(year):C(type) + scale(odometer):C(fuel) + C(manufacturer):C(cylinders) + C(type):C(drive) + scale(I(year**2)) + scale(I(year**3))\" 1result, train_data, test_data, train_ls, test_ls = usedcar.model_fit(model6_formula) 12score, result, cross_validation_model6 = usedcar.regularized_method( model6_formula, cv=10, alpha=0.00001, L1_wt=0) 1234prediction = result.predict(test_data[test_data.columns.difference( ['price'])])model_6_test_r2 = r2_score(np.log(test_data['price']), prediction)print(\"Model 6 R-sqaure : \", model_6_test_r2) 12345678final_result = { &quot;model 1&quot;: model_1_test_r2, &quot;model 2&quot;: model_2_test_r2, &quot;model 3&quot;: model_3_test_r2, &quot;model 4&quot;: model_4_test_r2, &quot;model 5&quot;: model_5_test_r2, &quot;model 6&quot;: model_6_test_r2,} 12345678910pd.DataFrame(final_result,index=[0]).plot.bar(figsize=(20,10))plt.ylim(0.8,0.9)plt.title('모델별 Test 데이터 R2 score')plt.tick_params( axis='x', # changes apply to the x-axis which='both', # both major and minor ticks are affected bottom=False, # ticks along the bottom Edge are off top=False, # ticks along the top Edge are off labelbottom=False) # labels along the bottom Edge are offplt.show() 가설검증 1 주행거리 5만킬로 미터 이하일 때 파는게 좋을것이다. 1sigma_2_df['vehicle'].value_counts()[:5] 123# 거래가 가장 많은 차종으로 선택data = sigma_2_df[sigma_2_df['vehicle'] == \"2012 Ford F-150 FX4\"]data = data[['price','year','odometer','drive','fuel','manufacturer','state','title_status','transmission','type','paint_color','cylinders']] 123456789def hypothesis_proof(df,result): # odometer 외의 컬럼은 다 최빈값으로 채운다 for column in df.columns.difference(['price','odometer']): df[column] = df[column].value_counts().keys()[0] df['odometer'] = range(0, len(df)*1000, 1000) df.reset_index(drop=True) return np.exp(result.predict(df)), df 1hypothesis_1, data = hypothesis_proof(data, result) 1234plt.figure(figsize=(20,9))plt.plot(hypothesis_1)plt.title(\"2012 Ford F-150 FX4 차량의 주행거리에 따른 가격 변화\")plt.show() 가설 1 결론 : 3만 마일 (약 48000km)부터 가격이 급격하게 떨어지는걸 볼수 있다. 가설검증 2 지역별 가격차이가 있을 것이다 12anova = sm.stats.anova_lm(result, typ=2)anova.sort_values(by=['F'], ascending=False).iloc[5:] 123456data = sigma_2_df[sigma_2_df['vehicle'] == \"2012 Ford F-150 FX4\"]plt.figure(figsize=(20,8))data.groupby('state').mean()['price'].sort_values(ascending=False).plot.bar()plt.xticks(rotation=0)plt.title(\"2012 Ford F-150 FX4\")plt.show() 회고Keep 분석 목적 가설 설정 EDA 및 전처리 Problem 자동차 보증수리 여부에 대한 데이터의 부재로, Model 5의 아이디어를 좀더 발전 시키지 못한 점 머신러닝 때 배운 페이스북 예측 모델 넣어서 예측해보기 Try 주기적으로 업데이트되는 데이터를 활용한 예측 진행","link":"/2020/04/25/project-LinearRegression/"},{"title":"python 조건문","text":"조건문 특정 조건에 따라서 코드를 실행하고자 할 때 사용 if, else, elif123456# if 문이 ture일 때 구문 안의 결과가 실행됨if True: print(\"python\")print(\"done\")# python done 123456# if 문이 false일 때 구문 이외의 결과가 실행됨if False: print(\"python\")print(\"done\")# done 123456789101112# 조건부문 : bool 데이터 타입 이외의 데이터 타입이 오면 bool으로 형변환 되어 판단# int : 0을 제외한 나머지 값은 Truenum = 0if num: print(\"python_1\")# 출력값 없음num = 1if num: print(\"python_2\")# python_2 12345number = 7if number % 2: print('홀수')else: print('짝수') 123# float : 0.0을 제외한 나머지 실수는 True# str : \"\"을 제외한 나머지 문자열은 True# list, tuple, dict : [], (), {}를 제외한 나머지는 True 123456789101112# 지갑에 돈이 10000원 이상 있으면 택시를 탑니다. # 2000원 이상이 있으면 버스를 탑니다. # 그렇지 않으면 걸어서 집에 갑니다. money = 5000if money &gt;= 10000: print('택시를 타고 집에 갑니다.')elif money &gt;= 5000: print('광역버스를 타고 집에 갑니다.')elif money &gt;= 2000: print('일반버스를 타고 집에 갑니다.')else: print(\"걸어서 집에 갑니다.\") 1234567891011121314# 계좌에 10000원이 들어있습니다. # 인출 금액을 입력 받습니다. # 인출 금액이 계좌에 있는 금액보다 크면 \"인출이 불가능합니다.\" 출력# 인출 금액이 계좌에 있는 금액보다 작으면 \"인출 되었습니다.\" 출력# 마지막에 현재 계좌의 잔액을 출력account = 10000draw_money = int(input(\"인출 금액을 입력하세요. : \"))if account &gt;= draw_money: account -= draw_money print(str(draw_money) + \"원이 인출되었습니다.\")else: print(\"인출이 불가능합니다. \" + str(draw_money - account) + \"원의 잔액이 부족합니다.\")print(\"현재 잔액은 \" + str(account) + \"원 입니다.\") 삼항연산자 간단한 if, else 구문을 한줄의 코드로 표현할 수 있는 방법 (True) if (condition) else (False)123456# data 변수에 0이면 \"zero\"출력, 아니면 \"not zero\"출력data = 0if data: print(\"not zero\")else: print(\"zero\") 12data = 1\"not zero\" if data else \"zero\" 반복문 반복되는 코드를 실행할 때 사용 while, for, break, continue list comprehention12345678# whiledata = 3while data: # 조건이 False가 될 때까지 구문의 코드를 실행 # 반복되는 코드 print(data) data -= 1 학생이 국어: 80점, 영어: 90점, 수학: 100점 while 문을 이용해서 총점과 평균을 출력학생의 점수는 list, dict 표현len(), dict.values(), list.pop() 1234567891011# listsubject = [\"korean\", \"english\", \"math\"]score = [80, 90, 100]total, avg = 0, 0while True: total = sum(score) avg= total / len(score) print('3과목 총점은 ' + str(total) + '점 입니다.' ) print('3과목 평균 점수는 {}점 입니다. '.format(avg)) break 12345678910points_dict = {\"korean\": 80, \"english\": 90, \"math\": 100}total, avg = 0, 0while True: total = sum(points_dict.values()) avg = total / len(subject) print(\"3과목 총점 : \", total) print(\"3과목 평균 : \", avg) break 123456789101112subjects_ls = [\"korean\", \"english\", \"math\"]points_ls = [80, 90, 100]points_dict = {\"korean\": 80, \"english\": 90, \"math\": 100}datas = points_ls.copy() # 깊은 복사 : 원본 데이터를 보존total, avg = 0, 0while datas: total += datas.pop()avg = total / len(points_ls)total, avg 무한루프 1234result = 1while result: result += 1print(result) break : 반복문을 중단 시킬 때 사용되는 예약어12345678result = 1while result: if result &gt;= 10: break result += 1print(result) for iterable한 데이터를 하나씩 꺼내서 value에 대입시킨 후 코드를 iterable변수의 값 갯수만큼 실행12for &lt;variable&gt; in &lt;iterables&gt;: &lt;code&gt; 123ls = [0, 1, 2, 3, 4]for data in ls: print(data) 12345678# continue: 조건부분으로 올라가서 콜드가 실행ls = [0, 1, 2, 3, 4]for data in ls: if data % 2: # data가 홀수가 되면 continue를 실행하여 다시 포문으로 돌아감 continue # data가 짝수이면 print를 실행 print(data, end=\" \") for를 이용해서 코드를 100번 실행 range 함수12345list(range(100))result = 0for data in range(100): result += dataresult offset index 개념과 비슷하게 사용1list(range(5)), list(range(5, 10)), list(range(0, 10, 2)) 12345# 0~10 까지 짝수를 더한 총합result = 0for number in range(0, 11, 2): result += numberresult 123points_dict = {\"korean\": 80, \"english\": 90, \"math\": 100}for data in points_dict: print(data) items 함수 사용 1234# dict 형태points_dict = {\"korean\": 80, \"english\": 90, \"math\": 100}for subject, point in points_dict.items(): print(subject, point) zip 함수 사용 123456# list 형태# for 문에서 iterable 데이터가 tuple로 나오면 여러개의 변수로 받을 수 있습니다. subjects_ls = [\"korean\", \"english\", \"math\"]points_ls = [80, 90, 100]for subject, point in zip(subjects_ls, points_ls): print(subject, point) 구구단 가로 출력 21=2 31=3 … 9*1=9 … 29=18 39=27 … 9*9=8112345for i in range(1, 10): # 1, 2, 3, ... 9를 만들어 줌# print(i) for j in range(2, 10): # 2단, 3단, ... 9단을 만들어줌 print('{}*{}={}'.format(j, i, i*j), end='\\t') print() List Comprehention 리스트 데이터를 만들어주는 방법 for문 보다 빠르게 동작합니다. 1234567# 각각 값에 제곱한 결과 출력ls = [0, 1, 2, 3]result = []for data in ls: result.append(data ** 2)result 12result = [data**2 for data in ls] # [연산 for 각각의 데이터 in 데이터의 집합]result 12345# 리스트 컴프리헨션을 써서 홀수와 짝수를 리스트로 출력해주는 코드# 삼항연산자 사용ls = range(0, 11)result = [\"홀수\" if data % 2 else \"짝수\" for data in ls]result 리스트 컴프리헨션 조건문 0 ~ 9까지에서 홀수만 출력하기12ls = range(10)[i for i in ls if i%2] 1234# dir(ls)에서 \"__\" 없는 함수만 출력하기ls = [1, 2, 3]dir(ls)[i for i in dir(ls) if i[:2] != '__'] # 앞에 2개가 __ 인 것을 제외 1234# 앞글자가 c인 것만 가져오기ls = [1, 2, 3]dir(ls)[i for i in dir(ls) if i[:2] != '__' if i[:1] == 'c'] 123ls = [1, 2, 3]dir(ls)[i for i in dir(ls) if i[:2] != '__' and i[0] == 'c'] for문과 list comprehention 성능 비교 12345%%timeit # magic command : 셀 안에서 실행되는 시간 측정ls = []for num in range(1, 10001): ls.append(ls)len(ls) 123%%timeit # magic command : 셀 안에서 실행되는 시간 측정ls = [num for num in range(1, 10001)]len(ls) 1234567# 3의 배수만 찾기 소요시간 비교%%timeit # magic command : 셀 안에서 실행되는 시간 측정ls = []for num in range(1, 10001): if num % 3 == 0: ls.append(num)len(ls) 123%%timeit # magic command : 셀 안에서 실행되는 시간 측정ls = [num for num in range(1, 10001) if num % 3 == 0]len(ls)","link":"/2020/05/10/python_condition_loop/"},{"title":"terminal_basic_command","text":"Mac Terminal basic command zsh : 2020 mac 기본 터미널 iTrem : 현재 사용하고 있는 터미널 oh my zsh : 터미널 설정 오픈소스 출처 현재위치 파악 및 폴더 이동하기 12345678$ pwd $ ll$ ls -al$ ls$ cd Documents$ cd ..$ cd Music/Music$ cd ~ pwd : 현재 위치의 절대 경로 ll : 폴더 ls -al : 폴더 상세내용 표시 ls : cd Documents : cd .. : cd Music/Music : cd ~ : 폴더, 파일 생성 및 삭제 명령어 참고사항 : 15번 $ 표시가 없는 esc는 esc를 입력하라는 것이 아닌 esc키를 누르라는 의미입니다. 12345678910111213$ mkdir test$ cd test$ touch test$ vi test $ i$ :set nu$ test esc$ :wq$ rm test$ ll$ cd ..$ rmdir test mkdir test : cd test : touch test : vi test : i : 터미널 창 왼쪽 아래 - - INSERT - - 라고 보이며, vi editor 내부에 글자를 적을 수 있습니다. :set nu : 에디터 내부에 라인이 설정됩니다. test : 테스트라고 작성해봅시다! 혹은 아무글자나 작성해봅시다. esc키를 누르면 왼쪽 아래 - - INSERT - - 가 사라집니다. wq : 작성한 내용을 저장 후 빠져나옵니다. rm test : test 파일을 삭제합니다. ll : 폴더 내부에 있는 내용물을 보여줍니다. cd .. : 상위 폴더로 이동합니다. rmdir test : test 폴더를 삭제합니다. 12$ ls$ ll ls : 현재 경로에 있는 폴더, 파일을 보여줍니다. ll : 현재 경로에 있는 폴더, 파일을 보여줍니다. 단, ls보다 상세하게 보여줍니다. (권한, 사용자계정 등) 터미널 이전 명령어 실행 12$ history$ !27 history : 과거에 입력한 명령어 보기 !27 : 27번에 실행했던 명령어 다시 실행하기 설치된 판다스 0.24.2버전으로 변경하기 12$ pip uninstall pandas$ pip install pandas==0.24.2 절대경로 1$ pwd /home/ubuntu/python3/database : 현재 위치의 절대 경로 / : 루트 절대경로로 이동 1$ cd /home/ubuntu/python3/daatabase/ 최상위 계정 접속 1$ cd / / : 결과 접속되어있는 계정의 최상위 디렉토리로 이동 1$ cd ~ /home/ubuntu : 결과 상대경로 1$ cd ./python3/database/ ./ : 현재위치, 생략가능 1$ cd ../notebook/ 위로 한단계 올라간 후 노트북 디렉토리로 이동 새로운 명령어를 알게될 때마다 추가 업데이트 예정입니다. 오탈자 및 조언 댓글로 남겨주세요.감사합니다 :)","link":"/2020/04/15/terminal-basic-command/"},{"title":"re(regular expression)","text":"정규표현식 regular expression 특정한 패턴과 일치하는 문자열를 ‘검색’, ‘치환’, ‘제거’ 하는 기능을 지원 정규표현식의 도움없이 패턴을 찾는 작업(Rule 기반)은 불완전 하거나, 작업의 cost가 높음 e.g) 이메일 형식 판별, 전화번호 형식 판별, 숫자로만 이루어진 문자열 등 raw string 문자열 앞에 r이 붙으면 해당 문자열이 구성된 그대로 문자열로 변환 12345a = 'abcdef\\n' # escapce 문자열print(a)b = r'abcdef\\n'print(b) 기본 패턴 a, X, 9 등등 문자 하나하나의 character들은 정확히 해당 문자와 일치 e.g) 패턴 test는 test 문자열과 일치 대소문자의 경우 기본적으로 구별하나, 구별하지 않도록 설정 가능 몇몇 문자들에 대해서는 예외가 존재하는데, 이들은 틀별한 의미로 사용 됨 . ^ $ * + ? { } [ ] \\ | ( ) . (마침표) - 어떤 한개의 character와 일치 (newline(엔터) 제외) \\w - 문자 character와 일치 [a-zA-Z0-9_] \\s - 공백문자와 일치 \\t, \\n, \\r - tab, newline, return \\d - 숫자 character와 일치 [0-9] ^ = 시작, $ = 끝 각각 문자열의 시작과 끝을 의미 \\가 붙으면 스페셜한 의미가 없어짐. 예를들어 \\.는 .자체를 의미 \\\\는 \\를 의미 자세한 내용은 링크 참조 https://docs.python.org/3/library/re.html search method 첫번째로 패턴을 찾으면 match 객체를 반환 패턴을 찾지 못하면 None 반환 12345678910import rem = re.search(r'abc', '123abdef')mm = re.search(r'\\d\\d\\d\\w', '112abcdef119')mm = re.search(r'..\\w\\w', '@#$%ABCDabcd')m metacharacters (메타 캐릭터)[] 문자들의 범위를 나타내기 위해 사용 [] 내부의 메타 캐릭터는 캐릭터 자체를 나타냄 e.g) [abck] : a or b or c or k [abc.^] : a or b or c or . or ^ [a-d] : -와 함께 사용되면 해당 문자 사이의 범위에 속하는 문자 중 하나 [0-9] : 모든 숫자 [a-z] : 모든 소문자 [A-Z] : 모든 대문자 [a-zA-Z0-9] : 모든 알파벳 문자 및 숫자 [^0-9] : ^가 맨 앞에 사용 되는 경우 해당 문자 패턴이 아닌 것과 매칭 1234567re.search(r'[cbm]at', 'aat')re.search(r'[0-4]haha', '7hahah')re.search(r'[abc.^]aron', 'daron')re.search(r'[^abc]aron', '0aron') \\ 다른 문자와 함께 사용되어 특수한 의미를 지님 \\d : 숫자를 [0-9]와 동일 \\D : 숫자가 아닌 문자 [^0-9]와 동일 \\s : 공백 문자(띄어쓰기, 탭, 엔터 등) \\S : 공백이 아닌 문자 \\w : 알파벳대소문자, 숫자 [0-9a-zA-Z]와 동일 \\W : non alpha-numeric 문자 [^0-9a-zA-Z]와 동일 메타 캐릭터가 캐릭터 자체를 표현하도록 할 경우 사용 \\. , \\\\ 123re.search(r'\\Sand', 'apple land banana')re.search(r'\\.and', '.and') . 모든 문자를 의미 1re.search(r'p.g', 'pig') 반복패턴 패턴 뒤에 위치하는 *, +, ?는 해당 패턴이 반복적으로 존재하는지 검사 ‘+’ -&gt; 1번 이상의 패턴이 발생 ‘*’ -&gt; 0번 이상의 패턴이 발생 ‘?’ -&gt; 0 혹은 1번의 패턴이 발생 반복을 패턴의 경우 greedy하게 검색 함, 즉 가능한 많은 부분이 매칭되도록 함 e.g) a[bcd]*b 패턴을 abcbdccb에서 검색하는 경우 ab, abcb, abcbdccb 전부 가능 하지만 최대한 많은 부분이 매칭된 abcbdccb가 검색된 패턴 1234567891011re.search(r'a[bcd]*b', 'abcbdccb')re.search(r'b\\w+a', 'banana')re.search(r'i+', 'piigiii')re.search(r'pi+g', 'pg')re.search(r'pi*g', 'pg')re.search(r'https?', 'http://www.naver.com') ^, $ ^ 문자열의 맨 앞부터 일치하는 경우 검색 $ 문자열의 맨 뒤부터 일치하는 경우 검색 123456789re.search(r'b\\w+a', 'cabana')re.search(r'^b\\w+a', 'cabana')re.search(r'^b\\w+a', 'babana')re.search(r'b\\w+a$', 'cabana')re.search(r'b\\w+a$', 'cabanap') grouping ()을 사용하여 그루핑 매칭 결과를 각 그룹별로 분리 가능 패턴 명시 할 때, 각 그룹을 괄호() 안에 넣어 분리하여 사용 1234m = re.search(r'(\\w+)@(.+)', 'test@gmail.com')print(m.group(1))print(m.group(2))print(m.group(0)) {} *, +, ?을 사용하여 반복적인 패턴을 찾는 것이 가능하나, 반복의 횟수 제한은 불가 패턴뒤에 위치하는 중괄호{}에 숫자를 명시하면 해당 숫자 만큼의 반복인 경우에만 매칭 {4} - 4번 반복 {3,4} - 3 ~ 4번 반복 1re.search('pi{3,5}g', 'piiiiig') 미니멈 매칭(non-greedy way) 기본적으로 *, +, ?를 사용하면 greedy(맥시멈 매칭)하게 동작함 *?, +?을 이용하여 해당 기능을 구현 123re.search(r'&lt;.+&gt;', '&lt;html&gt;haha&lt;/html&gt;')re.search(r'&lt;.+?&gt;', '&lt;html&gt;haha&lt;/html&gt;') {}? {m,n}의 경우 m번 에서 n번 반복하나 greedy하게 동작 {m,n}?로 사용하면 non-greedy하게 동작. 즉, 최소 m번만 매칭하면 만족 123re.search(r'a{3,5}', 'aaaaa')re.search(r'a{3,5}?', 'aaaaa') match search와 유사하나, 주어진 문자열의 시작부터 비교하여 패턴이 있는지 확인 시작부터 해당 패턴이 존재하지 않다면 None 반환 12345re.match(r'\\d\\d\\d', 'my number is 123')re.match(r'\\d\\d\\d', '123 is my number')re.search(r'^\\d\\d\\d', '123 is my number') findall search가 최초로 매칭되는 패턴만 반환한다면, findall은 매칭되는 전체의 패턴을 반환 매칭되는 모든 결과를 리스트 형태로 반환 1re.findall(r'[\\w-]+@[\\w.]+', 'test@gmail.com haha test2@gmail.com nice test test') sub 주어진 문자열에서 일치하는 모든 패턴을 replace 그 결과를 문자열로 다시 반환함 두번째 인자는 특정 문자열이 될 수도 있고, 함수가 될 수 도 있음 count가 0인 경우는 전체를, 1이상이면 해당 숫자만큼 치환 됨 1re.sub(r'[\\w-]+@[\\w.]+', 'great', 'test@gmail.com haha test2@gmail.com nice test test', count=1) compile 동일한 정규표현식을 매번 다시 쓰기 번거로움을 해결 compile로 해당표현식을 re.RegexObject 객체로 저장하여 사용가능 123email_reg = re.compile(r'[\\w-]+@[\\w.]+')email_reg.search('test@gmail.com haha good')email_reg.findall() 연습문제 아래 뉴스에서 이메일 주소를 추출해 보세요 다음중 올바른 (http, https) 웹페이지만 찾으시오 1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoup&gt; 위의 두 모듈이 없는 경우에는 pip install requests bs4 실행def get_news_content(url): response = requests.get(url) content = response.text soup = BeautifulSoup(content, 'html5lib') div = soup.find('div', attrs = {'id' : 'harmonyContainer'}) content = '' for paragraph in div.find_all('p'): content += paragraph.get_text() return contentnews1 = get_news_content('https://news.v.daum.net/v/20190617073049838')print(news1)email_reg = re.compile(r'[\\w-]+@[\\w.]+\\w+')email_reg.search(news1)webs = ['http://www.test.co.kr', 'https://www.test1.com', 'http://www.test.com', 'ftp://www.test.com', 'http:://www.test.com', 'htp://www.test.com', 'http://www.google.com', 'https://www.homepage.com.']web_reg = re.compile(r'https?://[\\w.]+\\w+$')list(map(lambda w:web_reg.search(w) != None, webs))","link":"/2020/04/24/re/"},{"title":"webcrawling","text":"1. 개발자 도구를 활용한 웹페이지 분석 chrome 기준 웹 브라우저 : html로 작성된 내용을 user(사람들)가 보기 쉽게 랜더링 해주는 기능을 함 Elements 탭 원하는 데이터로 이동하는 기능을 사용 엘레먼트 탭 : 왼쪽 상단에 있음, 원하는 데이터를 클릭했을 때 어떤 테그와 어떤 속성을 가지는지 표시해주는 역할을 함 어떤 태그와 속성을 가지는지 먼저 파악해야 함 Network 탭 Preserve log : 체크 시, 로그가 지워지지 않고 유지됨 브라우저가 서버에 요청되는 모든 요청을 로그함 url 확인 가능 요청이 많은 이유 : 이미지 등은 첫번째 요청에 한번에 오지 않고, 따로 요청하여 받아옴 처음엔 기본적인 데이터만 넘기고, 나머지 데이터는 브라우저에서 ajax 등의 기술을 이용해서 비동기적으로 가져갈 수 있도록 함 HTTP(Hyper Text Transfer Protocol) : HTML 문서 등의 리소스를 전송하는 프로토콜(규약) 클라이언트(user가 사용하는 브라우저)가 서버에 HTTP 요청(Get, Post 등) 서버에서 클라이언트로 HTTP 응답을 함 Get 요청 : 데이터를 url에 포함하여 전달(주로 리소스 요청에 사용), 정보의 공유가능 Post 요청 : 데이터를 Form data에 포함하여 전달(주로 로그인에 사용) rendering(렌더링) : html을 받아 사용자(사람들)이 볼 수 있도록 출력해주는 작업","link":"/2020/04/03/webcrawling-1/"},{"title":"webcrawling","text":"※ 출처 : fast campus 머신러닝 인강(변영효 강사님) 일부 내용만 발췌하였고, 기본적인 개념 및 추가내용을 확인하시려면 인강 수강을 권장드립니다. 내용요약 웹사이트에서 원하는 정보의 태그를 파악 모듈을 통해 태그를 찾은 후 원하는 값을 가져옴 2. HTML(Hyper Text Markup Language) 웹 사이트를 생성하기 위한 언어로 문서와 문서가 링크로 연결되어 있고, 태그를 사용하는 언어 태그 : HTML 문서의 기본 블락 브라우저에 어떻게 렌더링(화면에 표시)될지 전달 &lt;태그명 속성1=”속성값1” 속성2=”속성값2”&gt;Value&lt;/태그명&gt; &lt;태그명 속성1=”속성값1” 속성2=”속성값2”/&gt; p 태그 : paragraph tag 한 문단으로 표시해주는 태그 div 태그 그룹핑을 하는 태그 대부분의 crawling은 태그 안에 있는 값을 추출하는 작업입니다. html 기본구조 BeautifulSoup test Contents Title Test contents Test Test Test 1 Test Test Test 2 Test Test Test 3 웹 사이트에서 본인에게 필요한 정보를 가져오는 실습을 해보는걸 추천드립니다.","link":"/2020/04/21/webcrawling-2/"},{"title":"webcrawling","text":"python의 request 모듈을 사용하여 http request/resopnse 확인하기requests 모듈 http request/response를 위한 모듈 HTTP method를 메소드 명으로 사용하여 request 요청 예) get, post 123456789101112131415import requests# get 방식url = 'https://news.v.daum.net/v/20190728165812603'resp = requests.get(url)resp.text# post 방식url = 'https://www.kangcom.com/member/member_check.asp'data = { 'id': 'testid', 'pwd': 'password'}resp = requests.post(url, data=data)resp.text HTTP header 데이터 이용하기 header 데이터 구성하기 header 데이터 전달하기 1234567url = 'https://news.v.daum.net/v/20190728165812603'headers = { 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36'}resp = requests.get(url, headers=headers)resp.text HTTP response 처리하기 response 객체의 이해 status_code 확인하기 text 속성 확인하기 123456url = 'https://news.v.daum.net/v/20190728165812603'resp = requests.get(url)if resp.status_code == 200: resp.headerselse: print('error') BeautifulSoup의 find와 find_all 함수 find 함수 조건에 만족하는 하나의 tag만 검색 특정 html tag를 검색 검색 조건을 명시하여 찾고자하는 tag를 검색 12345678tag = soup.find('h3')tag.get_text()tag = soup.find('p')tag.get_text()tag = soup.find('div', id='upper')tag.get_text().strip() find_all함수 조건에 맞는 모든 tag를 리스트로 반환합니다. get_text 함수 tag안의 value를 추출 부모tag의 경우, 모든 자식 tag의 value를 추출 attribute 값 추출하기 경우에 따라 추출하고자 하는 값이 attribute에도 존재함 이 경우에는 검색한 tag에 attribute 이름을 [ ]연산을 통해 추출가능 예) div.find(‘h3’)[‘title’] 12tag = soup.find('h3')tag['title'] CSS의 select_one과 select 함수 CSS를 이용하여 tag 찾기 select, select_one함수 사용 css selector 사용법 태그명 찾기 tag 자손 태그 찾기 - 자손 관계 (tag tag) 자식 태그 찾기 - 다이렉트 자식 관계 (tag &gt; tag) 아이디 찾기 #id 클래스 찾기 .class 속성값 찾기 [name=’test’] 속성값 prefix 찾기 [name ^=’test’] 속성값 suffix 찾기 [name $=’test’] 속성값 substring 찾기 [name *=’test] n번째 자식 tag 찾기 :nth-child(n)","link":"/2020/04/21/webcrawling-3/"},{"title":"webcrawling","text":"web crawling 하기전에 알아둬야 할 사항 예를들어, 네이버 홈페이지를 크롤링한다고 하면 www.naver.com/robots.txt을 브라우저 주소창에 입력하면 로봇 배제 규약에 관한 내용이 나옵니다. robots.txt 내용 요약 모든 로봇 접근 허락User-agent: *Allow : / 모든 로봇 접근 차단User-agent: *Disallow: / 모든 로봇에 디렉토리 3곳 접근 차단User-agent: *Disallow: /cgi-bin/Disallow: /tmp/Disallow: /junk/ 모든 로봇에 특정 파일 접근 차단User-agent: *Disallow: /directory/file.html BadBot 로봇에 모든 파일 접근 차단User-agent: BadBotDisallow: / BadBot과 Googlebot에 특정 디렉토리 접근 차단User-agent: BadBotUser-agent: GooglebotDisallow: /private/ 참고사항 2020년 4월 21일 현재 네이버 로봇 규약 설정출처: https://searchadvisor.naver.com/guide/seo-basic-robots 사이트의 루트 페이지만 수집 허용으로 설정합니다.User-agent: *Disallow: /Allow: /$ sitemap.xml 지정User-agent: *Allow: /Sitemap: http://www.example.com/sitemap.xml 다음 로봇 규약 설정 모든 로봇의 접근 차단User-agent: *Disallow: / 카카오 로봇 규약 설정 모든 로봇의 접근 차단 See http://www.robotstxt.org/wc/norobots.html for documentation on how to use the robots.txt file To ban all spiders from the entire site uncomment the next two lines:User-agent: *Disallow: / 문제가 있거나 오타가 있으면 댓글이나 메일로 알려주세요.감사합니다 :) 자세한 내용은 아래 사이트를 참조하세요.출처: https://gbsb.tistory.com/80출처: https://medium.com/@euncho/robots-txt-e08328c4f0fd출처: https://support.google.com/webmasters/answer/6062596?hl=ko출처: https://ko.wikipedia.org/wiki/%EB%A1%9C%EB%B4%87_%EB%B0%B0%EC%A0%9C_%ED%91%9C%EC%A4%80","link":"/2020/04/21/webcrawling-robots.txt/"}],"tags":[{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"query","slug":"query","link":"/tags/query/"},{"name":"concept","slug":"concept","link":"/tags/concept/"},{"name":"agile","slug":"agile","link":"/tags/agile/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"create","slug":"create","link":"/tags/create/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"logo","slug":"logo","link":"/tags/logo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"adsense","slug":"adsense","link":"/tags/adsense/"},{"name":"visit","slug":"visit","link":"/tags/visit/"},{"name":"cheatsheet","slug":"cheatsheet","link":"/tags/cheatsheet/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"favicon","slug":"favicon","link":"/tags/favicon/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"sourcetree","slug":"sourcetree","link":"/tags/sourcetree/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"eda","slug":"eda","link":"/tags/eda/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"basic syntax","slug":"basic-syntax","link":"/tags/basic-syntax/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"anaconda","slug":"anaconda","link":"/tags/anaconda/"},{"name":"jupyter notebook","slug":"jupyter-notebook","link":"/tags/jupyter-notebook/"},{"name":"LinearRegression","slug":"LinearRegression","link":"/tags/LinearRegression/"},{"name":"codition","slug":"codition","link":"/tags/codition/"},{"name":"loop","slug":"loop","link":"/tags/loop/"},{"name":"terminal command","slug":"terminal-command","link":"/tags/terminal-command/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"iTerm","slug":"iTerm","link":"/tags/iTerm/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"webcrawling","slug":"webcrawling","link":"/tags/webcrawling/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"get","slug":"get","link":"/tags/get/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"randering","slug":"randering","link":"/tags/randering/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"robots.txt","slug":"robots-txt","link":"/tags/robots-txt/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"concept","slug":"concept","link":"/categories/concept/"},{"name":"terminal","slug":"terminal","link":"/categories/terminal/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"mysql","slug":"AWS/mysql","link":"/categories/AWS/mysql/"},{"name":"agile","slug":"concept/agile","link":"/categories/concept/agile/"},{"name":"cheatsheet","slug":"cheatsheet","link":"/categories/cheatsheet/"},{"name":"tmux","slug":"terminal/tmux","link":"/categories/terminal/tmux/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"favicon","slug":"favicon","link":"/categories/favicon/"},{"name":"create","slug":"hexo/create","link":"/categories/hexo/create/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"query","slug":"AWS/mysql/query","link":"/categories/AWS/mysql/query/"},{"name":"project","slug":"project","link":"/categories/project/"},{"name":"profile","slug":"hexo/profile","link":"/categories/hexo/profile/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"adsense","slug":"hexo/adsense","link":"/categories/hexo/adsense/"},{"name":"command","slug":"terminal/command","link":"/categories/terminal/command/"},{"name":"crawling","slug":"crawling","link":"/categories/crawling/"},{"name":"concept","slug":"git/concept","link":"/categories/git/concept/"},{"name":"branch","slug":"git/branch","link":"/categories/git/branch/"},{"name":"sourcetree","slug":"git/sourcetree","link":"/categories/git/sourcetree/"},{"name":"EDA","slug":"project/EDA","link":"/categories/project/EDA/"},{"name":"class","slug":"python/class","link":"/categories/python/class/"},{"name":"basic syntax","slug":"python/basic-syntax","link":"/categories/python/basic-syntax/"},{"name":"function","slug":"python/function","link":"/categories/python/function/"},{"name":"jupyter netebook","slug":"python/jupyter-netebook","link":"/categories/python/jupyter-netebook/"},{"name":"LinearRegression","slug":"project/LinearRegression","link":"/categories/project/LinearRegression/"},{"name":"condition","slug":"python/condition","link":"/categories/python/condition/"},{"name":"re","slug":"python/re","link":"/categories/python/re/"},{"name":"concept","slug":"crawling/concept","link":"/categories/crawling/concept/"},{"name":"python","slug":"crawling/python","link":"/categories/crawling/python/"},{"name":"loop","slug":"python/condition/loop","link":"/categories/python/condition/loop/"}]}